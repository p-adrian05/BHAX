<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <screen>
        <![CDATA[
<utasítás>::=
    <összetett_utasítás> | <feltételes_utasítás> | <iterációs_utasítás> | 
    <vezérlés_átadó_utasítás> |  <címkézett_utasítás> | <kifejezés_utasítás>| <nulla_utasítás>
<összetett_utasítás>::= <deklaráció_lista> | <utasításlista>
<deklaráció_lista>::= <deklaráció>
<utasításlista>::= <utasítás>
<feltételes_utasítás>::= if | if else | switch
<iterációs_utasítás>::= while | do while | for
<vezérlés_átadó_utasítás>::= break | return | goto | continue
<címkézett_utasítás>::= <azonosító>
<kifejezés_utasítás>::= <kifejezés>
<nulla_utasítás>::= ;

        ]]>
    </screen>

 <para>C99-el lefordul:</para>                                                                      
 <programlisting>
         <![CDATA[
    #include <stdio.h>

    int main ()
    {
      // Printing to screen.
      printf ("Hello World\n");
    }
 ]]>  
         </programlisting>
 <screen>
         <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ gcc -o a -std=c99 a.c
adrian@adrian-MS-7817:~/Desktop/programs$ 
 ]]>
 </screen>
 <para>Azonban C89-el nem fordul le:</para>
    
 <screen>
         <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ gcc -o a -std=c89 a.c
a.c: In function ‘main’:
a.c:5:7: error: C++ style comments are not allowed in ISO C90
       // Printing to screen.
       ^
a.c:5:7: error: (this will be reported only once per input file)
 ]]>
 </screen>

    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
         
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/realnumber.l">https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/realnumber.l</link>
        </para>
        <para>
            A lexer minta illesztésen alapulva legenerálja a lexikális elemzőnket, nekünk csak a mintát kell megadnunk, ami alapján figyeli a begépelt 
            szöveget. Ebben a feladatban olyan programot írunk, ami a begépelt szövegből felismeri és megszámolja a valós számokat.
        </para>
        <programlisting>
         <![CDATA[
%{
#include <stdio.h>
int realnumbers = 0;
%}
digit	[0-9]
%%
{digit}*(\.{digit}+)?	{++realnumbers; 
    printf("[realnum=%s %f]", yytext, atof(yytext));}
%%
int
main ()
{
 yylex ();
 printf("The number of real numbers is %d\n", realnumbers);
 return 0;
}         
         ]]>
         
         </programlisting>
         <para>
            Az első részben deklarálunk egy int változót, amit növelve kapjuk meg a számok számát és 
            végén definiáljuk digit néven 0-9-ig a számjegyeket.
             <programlisting><![CDATA[
%{
#include <stdio.h>
int realnumbers = 0;
%}
digit [0-9]
    ]]>  </programlisting>   
    </para>

    <para>
            A második részben adjuk a mintát. A * előtt a digit, azt jelenti, hogy digitből(számból)
            bármennyi lehet. A . önmagában azt jelenti, hogy bármilyen karakterre rá lehet illeszteni, azonban
            nekünk le kell védeni \ jellel és így a valós számoknál lévő pontot fogja értelmezni. Utána digit, vagyis megint jönnek a számjegyek, a + 
            pedig azt jelenti, hogy legalább 1 számnak kell lennie a pont után. És ha van találat a mintára, akkor növeljük a realnumbers változót.
            Ezután kiiratjuk a felismert számot, illetve az atof-al átkonvertált double verzióját is.
             <programlisting><![CDATA[
%%
{digit}*(\.{digit}+)? {++realnumbers;
printf("[realnum=%s %f]", yytext, atof(yytext));}
%%
    ]]>  </programlisting>   
    </para>

    <para>
        A harmadik rész maga a program, ahol meghívjuk a lexert, ami összerakja a fenti minta alapján a programunkat és a program befejezte után
        kiírja a talált számokat.
    </para>

    <para>
        Fordításkor először a lexnek megmondjuk milyen kimenetet készítsen a fent megírt realnumber.l forrásból. Ezután szokott módon
        fordítjuk a kapott c forráskódot hozzálinkelve a flex könyvtárat.
    </para>
    <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ clear
adrian@adrian-MS-7817:~/Desktop/programs$ lex -o realnumber.c realnumber.l
adrian@adrian-MS-7817:~/Desktop/programs$ gcc realnumber.c -o realnumber -lfl
        ]]>
    </screen>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
                <para>Ha a SIGINT jel kezelése nem volt figyelmen kívűl hagyva, akkor a jelkezelo függvény kezelje, máskülönben figyelmen kívűl 
                        legyen hagyva.
                </para>
            </listitem>
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>  
                <para>for ciklussal 0-tól 4-ig megyünk, az i-t növelve. ++i azt jelenti, hogy megnöveli
                    az i étékét majd visszaadja az 1-el megnövelt értéket.
                </para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>   
                 <para>for ciklussal 0-tól 4-ig megyünk, az i-t növelve. i++ azt jelenti, hogy megnöveli
                    az i étékét, de először visszaadja az eredeti értéket és azután növeli. For ciklusban
                    nincs jelentősége, hogy ++i vagy i++;
                </para>          
            </listitem>
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>       
                <para> Indulunk for ciklussal 0-tól 4-ig, majd tomb ielemét megváltoztatjuk arra az i-re ami megnövelés előtt volt. </para>
            
            <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ splint a.c
Splint 3.1.2 --- 20 Feb 2018

a.c: (in function main)
a.c:9:26: Expression has undefined behavior (left operand uses i, modified by
             right operand): tomb[i] = i++
  Code has unspecified behavior. Order of evaluation of function parameters or
  subexpressions is not defined, so if a value is used and modified in
  different places not separated by a sequence point constraining evaluation
  order, then the result of the expression is unspecified. (Use -evalorder to
  inhibit warning)
a.c:15:2: Path with no return in function declared to return int
  There is a path through a function declared to return a value on which there
  is no return statement. This means the execution may fall through without
  returning a meaningful result to the caller. (Use -noret to inhibit warning)

Finished checking --- 2 code warnings


        ]]>
    </screen>
            </listitem>
            
            <listitem>                                    

                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting> 
                <para>  
                    0-tól megyünk for ciklussal, addig amíg i kisebb mint n és ha d tömbre muntató mutató következő
                    eleme egyenlő az s mutató által mutatatott tömb következő elemével. Hiba: összehasonlításkor 2db 
                    egyelnőségjelet használunk.
                </para>           
            </listitem>
     
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>  
                 <para> Kiiratunk két egész számot. Mindkettőt az f függvény adja vissza. Első esetben az f függvénynek
                        átadjuk az a változót és az a változó 1-el megnövelt értékét. Másodszor pedig az a változó 1-el megnövelt értékét és a-t adjuk átadjuk
                        az f függvénynek.
                 </para> 
                  <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ splint a.c
Splint 3.1.2 --- 20 Feb 2018

a.c: (in function main)
a.c:16:22: Argument 2 modifies a, used by argument 1 (order of evaluation of
              actual parameters is undefined): f(a, ++a)
  Code has unspecified behavior. Order of evaluation of function parameters or
  subexpressions is not defined, so if a value is used and modified in
  different places not separated by a sequence point constraining evaluation
  order, then the result of the expression is unspecified. (Use -evalorder to
  inhibit warning)
a.c:16:30: Argument 1 modifies a, used by argument 2 (order of evaluation of
              actual parameters is undefined): f(++a, a)
a.c:16:17: Argument 2 modifies a, used by argument 3 (order of evaluation of
    actual parameters is undefined): printf("%d %d", f(a, ++a), f(++a, a))
a.c:16:28: Argument 3 modifies a, used by argument 2 (order of evaluation of
    actual parameters is undefined): printf("%d %d", f(a, ++a), f(++a, a))
a.c:2:5: Function exported but not used outside a: f
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   a.c:6:1: Definition of f

Finished checking --- 5 code warnings
        ]]>
</screen>        
            </listitem>
                   
            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>        
                    <para> Két egész számot iratunk ki, az egyik az f függvény által visszaadott szám, az a változót átadjuk az f-nek, a másik pedig az a változó.</para>
            <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ splint a.c
Splint 3.1.2 --- 20 Feb 2018

a.c:2:5: Function exported but not used outside a: f
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   a.c:6:1: Definition of f

Finished checking --- 1 code warning

        ]]>
</screen>
            </listitem>

            <listitem>                                    

                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>          
                 <para> Két egész számot iratunk ki, az egyik az f függvény által visszaadott szám, az a változó memóriacímét átadjuk az f-nek, a másik pedig az a változó.</para>
           <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/programs$ splint a.c
Splint 3.1.2 --- 20 Feb 2018

a.c: (in function main)
a.c:16:19: Function f expects arg 1 to be int gets int *: &a
  Types are incompatible. (Use -type to inhibit warning)
a.c:2:5: Function exported but not used outside a: f
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   a.c:6:1: Definition of f

Finished checking --- 2 code warnings


        ]]>
</screen>
            </listitem>
            
        </orderedlist>
        <para>
            Megoldás forrása:  
        </para>

        <para>
            Megoldás videó: 
        </para>

        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/Matlog/matlog.tex">https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/Matlog/matlog.tex</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

    <para>
        Ahhoz, hogy a fenti mondatatokat megadjuk, definiálni kell következőket:
    </para>
        <programlisting language="tex">    
<![CDATA[
$ (x \text{ páros}) \leftrightharpoons \exists y(y+y=x)$
$ (x < y) \leftrightharpoons \exists z(z+x=y) \wedge \neg (x=y)$ 
$(x \vert y) \leftrightharpoons \exists z ( z \cdot x=y )\wedge ( x \neq 0)$ 
$(x \text{ prím}) \leftrightharpoons  (\forall z( z \vert x )\supset ( z = x \vee z=S0))\wedge ( x \neq 0)\wedge ( x \neq S0)$ 
]]></programlisting>  
        <para>
        Majd ezt lefordítva pdf formátumba ezt kapjuk:
        </para>
        <mediaobject>
                <imageobject>
                    <imagedata fileref="img/matlog.jpg" scale="90" />
                </imageobject>
         </mediaobject>

         <para>
            x akkor páros, ha van olyan y változó, amihez önmagát hozzáadva x-et kapjuk.
         </para>
        <para>
            x kisebb mint y, ha van olyan z változó, amihez x-et hozzáadva y-t kapjuk és x nem egyenlő y-nal.
        </para>
         <para>
            x osztója y-nak, ha létezik olyan z változó, hogy ha z-t megszorozzuk x-el, y-t kapjuk és x nem egyenlő 0-val.
        </para>
        <para>
            x prímszám,  ha minden olyan z változó osztója x-nek ami egyenlő x-el vagy 1-gyel és x nem egyenlő 0-val és 1-gyel.
        </para>
        <para>
            Végtelen sok prímszám van: Minden x változó esetén van olyan y változó, amely nagyobb mint x és y prímszám.
        </para>
        <para>
            Végtelen sok iker-prímszám van: Minden x változó esetén van olyan y változó, amely nagyobb mint x, prímszám és hozzáadva kettőt is prímszám.
        </para>
        <para>
            Véges sok prímszám van: Van olyan y változó, amely minden x változó esetén, ha x prím, akkor nagyobb mint x.
        </para>
        <para>
            (2. megfogalmazás) Véges sok prímszám van: Van olyan y változó, amely ha minden x változó esetén, kisebb mint x, akkor x nem prímszám.
        </para>
   </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>                        
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>                        
            </listitem>            
        </itemizedlist>            
    <programlisting language="c">    
<![CDATA[

int *pointerFg(int *c)
{
    return c;
}

int fuggveny(int a, int b)
{
    return a;
}

typedef int(*A) (int,int);;
A fuggveny2(int);


int main()
{
    //egesz
    int a = 1;

    //egeszre mutato mutato
    int *b;

    //egesz referenciaja
    b = &a;

    //egeszek tombje
    int tomb[5] = {1,2,3,4,5};

    //egeszek tombjenek referenciaja
    int (&tombref)[5] = tomb;

    //egeszre mutato mutatok tombje
    int *tombMutato[5];

    //egeszre mutato mutatot visszaado fuggveny
    int *c = pointerFg(&a);

    //egeszre mutato mutatot visszaado fuggvenyre mutato mutato
    int *(*mutato)(int*) = pointerFg;

    //egeszet visszaade es ket egészet kapo fuggvenyre mutato mutatot visszaado, egeszet kapo fuggveny
    A st = fuggveny2(10);


}
]]></programlisting> 
       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>  
                <para>Egy int típusú a nevű változó.</para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>   
                <para>b egészre mutató mutató a-ra mutat.</para>          
            </listitem>
            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>
                <para>r egeszre mutató mutató, ami a címet tartalmazza.</para>             
            </listitem>
            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>     
                <para>Öt elemű egészekból álló tömb.</para>        
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>  
                <para>Öt elemű egészekből álló tombre mutató mutató, ami a c tömbre mutat.</para>           
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting> 
                <para>5 elemű egészekre mutató mutatókból álló tömb.</para>        
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting> 
                <para>Egy egésszel visszatérő paraméter nélküli függvényre mutató mutató.</para>           
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting> 
                <para>Egy egészre mutató mutatóval visszatérő, paraméter nélküli függvényre mutató mutató.</para>           
            </listitem>
            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>   
                <para>Egy egésszel visszatérő 2 egészet váró függvényre mutató mutatóval 
                        visszatérő 2 egészet váró függvény.
                </para>         
            </listitem>            
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting> 
                <para>Függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre mutató mutató. </para>        
            </listitem>            
        </itemizedlist>       


        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/deklaracio.c">https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/Chomsky/deklaracio.c</link> 
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
