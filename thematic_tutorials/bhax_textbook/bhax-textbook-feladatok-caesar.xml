<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
         <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <programlisting language="c"><![CDATA[#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;

    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }

    for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }

    for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}]]></programlisting>
        

        <para>
            A képen a double ** háromszögmátrix memóriafoglalását bemutató ábrát láthatjuk.
            Az <command>nr</command> változóval megadjuk a háromszögmátrix magasságát. Jelen esetben ez 5 lesz.
            A <command>double ** tm</command> egy mutatóra mutató mutató.
            A <command> malloc</command>-al foglalunk memóriát ami egy mutatót ad vissza a lefoglalt
            területre (double * mutatót), amit double ** mutatóvá típuskényszerítjük, így a tm mutatónkat rá tudjuk állítani erre a tárterületre.
            A <command> malloc</command>-nak átadjuk
            mekkora területet foglaljon le. Ebben az esetben a double * mutató mérete, ami 8, szorozva az nr változóval,
            így 40 -et kapva ennyi bájtot foglalunk a memóriába.
        </para> 
        <para>
        Ezután egy for ciklussal végigmegyünk ezen a területen 1-5-ig és minden double * mutatót is ráállítunk egy double típusú
        területre, aminek a darabszámát mindig egyel növeljük,így az első mutató 1db double-re mutat, a második 2-re és így tovább haladva 5-ig, így 
        kapjuk meg a háromszögmátrixot. Ezután értékeket adunk a változóinknak és kiiratjuk őket, majd felszabadítjuk a lefoglalt területeket.
        </para>   
 <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop/BHAX/textbook_programs/Caesar$ ./tm
0.000000, 
1.000000, 2.000000, 
3.000000, 4.000000, 5.000000, 
6.000000, 7.000000, 8.000000, 9.000000, 
10.000000, 11.000000, 12.000000, 13.000000, 14.000000, 
0.000000, 
1.000000, 2.000000, 
3.000000, 4.000000, 5.000000, 
6.000000, 7.000000, 8.000000, 9.000000, 
10.000000, 11.000000, 12.000000, 13.000000, 14.000000, 

        ]]>
        </screen>  
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
        Ebben a feladatban a kizáró vagyos (XOR) titkosítás van bemutatva. A kizáró vagyos
        titkosításkor a titkosítandó szöveg bájtjait lefedjük a titkosító
        kulcs bájtjaival és egy kizáró vagy múveletet végzünk el rajtuk. A kizáró vagy művelet
        1 értéket ad, ha a két bit különböző és 0-t ha megegyező. Például:
        </para>  
        <screen>
        <![CDATA[
            Kódolás:
            A tiszta szöveg bájtja:                         10011
            A kulcs bájtja:                                 00110
            A titkosított szöveg bájtjai XOR művelet után:  10101

            Dekódolás:
            A kulcs bájtja:                                     00110
            A titkosított szöveg bájtjai:                       10101
            XOR művelet után visszakapjuk az eredeti szöveget:  10011
        ]]>
        </screen>  
                   <programlisting>
         <![CDATA[
#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256


int
main (int argc, char **argv)
{

  char kulcs[MAX_KULCS];
  char buffer[BUFFER_MERET];

  int kulcs_index = 0;
  int olvasott_bajtok = 0;

  int kulcs_meret = strlen (argv[1]);
  strncpy (kulcs, argv[1], MAX_KULCS);

  while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
    {

      for (int i = 0; i < olvasott_bajtok; ++i)
	{

	  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	  kulcs_index = (kulcs_index + 1) % kulcs_meret;

	}

      write (1, buffer, olvasott_bajtok);

    }
}
 ]]>  
         </programlisting>   
         <para>
            A program elején definiáljuk a kulcs maximum méretét és a beolvasáshoz szükséges buffer méretét.
            Ezután a main függvényben létrehozzuk az ezekkel a méretekkel rendelkező char típusú tömböket.
            A kulcs_index változó mutatja az aktuális elemét a kulcsnak, amivel majd végrehajtjuk a műveletet,
            az olvasott_bajtok pedig a beolvasott bájtok számát fogja tárolni.
            Az <command>strlen()</command> függvény segítségével rögzítjuk a kulcs méretét amit a parancssorban adunk
            meg argumentumként.
            A while ciklus addig fut, amíg tudunk olvasni a bemenetről és azt tároljuk a bufferben, ha beolvasott szöveg
            végéhez értünk, akkor a <command>read()</command> függvény 0 értéket ad vissza és a ciklus véget ér.
            A while ciklusban végigmegyünk a beolvasott bájtokon és végrehajtjuk a tikosítást alkalmazva a kizáró
            vagy műveletet, majd az eredményt kiírjuk egy dokumentumba.
         </para>  
         <para>Fordítákor a c99 szabványt kell használnunk:</para>
         <screen>
        <![CDATA[
            gcc exor.c -o e -std=c99
        ]]>
         </screen>   
          <para>Eztuán létrehozunk egy szövegfájlt, amiben tároljuk a titkosítandó szövegünket</para>
         <screen>
<![CDATA[
    adrian@adrian-MS-7817:~/Desktop$ more tiszta.szoveg
    Nem tudok kimerítő leírást adni arról, hogy hogyan tudsz megtanulni
    programozni -- nagyon összetett tudásról van szó. Egyet azonban
    elárulhatok: a könyvek és tanfolyamok nem érnek túl sokat (sok,
    valószínűleg a legtöbb hacker autodidakta). Aminek van értelme:
     (a) kódot olvasni és kódot írni.
 ]]>
         </screen> 
     <para>Majd futtatjuk a programot megadva paraméterként a kulcsot és a 
            tiszta.szoveg fájlunk tartalmát a programba irányítjuk (ezt olvassa be). A kimenő
            adatokat pedig a titkos.szoveg nevű fájlba irányítjuk. Ez lesz a titkosított szövegünk.
     </para>
         <screen>
 <![CDATA[
 adrian@adrian-MS-7817:~/Desktop$ ./e kulcs <tiszta.szoveg >titkos.szoveg
     ]]>
         </screen>  
 <para>Kiírva a tikos.szoveg tartalmát láthatjuk a kódolt szövegünket:</para>
         <mediaobject>
                <imageobject>
                    <imagedata fileref="img/exor.png" scale="50" />
                </imageobject>
         </mediaobject>
<para>A dekódolás hasonlóan zajlik. Megadjuk azt a kulcsot amivel a kódolás történt és beolvassuk
        a tikos.szoveg tartalmat.
</para>
         <screen>
        <![CDATA[
adrian@adrian-MS-7817:~/Desktop$ ./e kulcs <titkos.szoveg
Nem tudok kimerítő leírást adni arról, hogy hogyan tudsz megtanulni
programozni -- nagyon összetett tudásról van szó. Egyet azonban
elárulhatok: a könyvek és tanfolyamok nem érnek túl sokat (sok,
valószínűleg a legtöbb hacker autodidakta). Aminek van értelme:
(a) kódot olvasni és kódot írni.

        ]]>
         </screen> 

    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
 <programlisting>
         <![CDATA[
public class ExorTitkosító {
    
    public ExorTitkosító(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new ExorTitkosító(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}
 ]]>  
         </programlisting>   

        <para>
           Javaban egy ExorTitkosító publikus osztályt vagy objektumot hozunk létre amiben a munkát végezzük.
           Először létrehozzuk a konstruktort, amivel majd átadjuk az objektumnak a kapott értékeket.
           Jelen esetben a paraméterként átadott kulcsot tároljuk egy stringbe, majd a bejövő és kijövő
           csatornát hozzuk létre.
           Egy byte tömben tároljuk a megadott kulcs bájtjait, illetve a buffer méretet.
           A while ciklusba addig olvasunk az int típusú beolvasottBájtok nevű változónkba,
           amíg -1-et nem kapunk, és egy for ciklussal iterálunk az olvasott bájtokon egyesével végezve
           a kizáró vagy műveletet a kulcsunk bájtjaival, amit tárolunk buffer tömbben.Végül a kimenő csatornán kiiratjuk a titkosított szöveget.
            A main() metódusban példányosítjuk az ExorTitkosító objektumunkat és átadjuk neki
            a paraméterként kapott kulcsot és a be és kimenő csatornát Mindezt try és catch ágba téve, az esetleges
            hibák elkapásához.
            
        </para>            
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
