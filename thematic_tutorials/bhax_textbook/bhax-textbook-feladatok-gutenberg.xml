<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
        <cover>
            <para>
                Programozás tankönyvek rövid olvasónaplói.
            </para>
        </cover>
    </info>
    <section>
        <title>Programozási alapfogalmak</title>     
        <para>Juhász István - Magas szintű programozási nyelvek 1</para>   
        <para>
            A programnyelvek három szintjét különböztetjük meg: gépi nyelv, assembly szintű nyelv, magas szintű nyelv.
            A magas szintű nyelven nyelven megírt programot forrásprogramnak nevezzük. Összeállítását szintaktikai és szemantikai
            szabályok alapján vegzi a fordító program ami gépi nyelvre fordítja a programot, hogy a processzor végre tudja hajtani
            a programot. A fordítóprogram a következő lépéseket hajtja végre: lexikális elemzés, szintaktikai elemzés, szemantikai elemzés,
            kódgenerálás. A másik technika egy forrásprogram végrehajtására az interpreteres technika, ami nem készít tárgyprogramot, hanem
            az utasításokat értelmezi és azonnal végre is hajtja. Minden programnyelvnek megvan a saját szabványa, amit hivatkozási nyelvnek
            hívunk. </para>
        <para>Programnyelvek osztályozása</para> 
        <para>Imperatív nyelvek: a programozó egy programszöveget ír, algoritmust kódol ami működteti a processzort.
             Alcsoportjai: eljárásorientált és objektumorientált nyelvek.
        </para>
        <para>Deklaratív nyelvek: Nem algoritmikus nyelvek, a proramozó csak a problémát oldja meg, a nyelvi implementációkban
            van beépítve a megoldás megkeresésének módja, a programozónak nincs lehetősége memóriaműveletekre. Alcsoportjai:
            Funkcionális és logikai nyelvek.
        </para>
        <para>Karakterkészlet</para>
         <para> 
            Minden program forrászövegének legkisebb alkotórészei a karakterek, amit minden nyelv definiál 3 kategóriába: betűk, számjegyek
            egyéb karakterek.
            A lexikális egységek a program azon elemei, melyeket a fordító a lexikális elemzés során felsimer és tokenizál. Fajtái: 
            többkarateres szimbólum, szimbolikus név, címke, megjegyzés, literál.
            A többkarateres szimbolumok olyan karaktersorozatok, amelyeknek csak a nyelv tulajdonít jelentést.Pl.: ++, --, /*,*/.
            Szimbolikus nevek közül az azonosító olyan karaktersorozat, ami betűvel kezdődik és betűvel vagy számjeggyel folytatódhat.
            A kulcsszavak vagy védett szavak olyan szavak amelyeknek a nyelv jelentést tulajdonít. Pl.: if, for, case, break.
            A stantard azonosítónak a nyelv tulajdonít jelentést, de a programozó által megváltoztatjató, például a NULL.
            A megjegyzés olyan programozási eszköz, melynek segítségével a programban olyan karaktersorozatok írása megengedett, amelyek
            nem a fordítónak szól, hanem a programot olvasónak. Általában a ezek a program működésével kapcsolatos magyarázó szövegek.
            A literál pedig olyan eszköz aminek segítségével fix értékek építhetők be a program szövegébe.
         </para>
         <para>Adattípusok</para>
         <para>
            Az adattípusnak van egy neve, ami egy azonosító. Minden adattípus mögött van egy belső ábrázolális mód. A reprezentáció
            az egyes típusok tartományába tartozó értékek tárban való megjenelését határozza meg, tehát, hogy az egyes elemek hány bájtra képződnek le.
            Saját típust úgy tudunk létrehozni, hogy megadjuk a tartományát, a műveleteit és a reprezentációját. Két nagy csoportjuk van:
            az egyszerű adattípus, tartománya atomi értékeket tartalmaz és összetett adattípus, aminek tartományának elemei is valamilyen
            típussal rendelkeznek.
            Az egyszerá adattípusba tartozik az egész típus, belső ábrázolásuk fix pontos.A valós típusok belső ábrázoláluk lebegőpontos.
            A karakteres típus elemei karakterek, karakterlánc típusé pedig karaktersorozatok. A logikai típus, igaz vagy hamis értéket tárol.
            Az összetett típusok közül a két legfontosabb a tomb és a rekord. A tömb statikus és homogén összetett típus, amelyben az elemek azonos
            típusúak. A tömböt mint típust meghatározza a dimenzióinak száma, hány sor, hány oszlopból áll, az elemek indexei, elemek sorszáma, amely egész típusú és az elemek típusa.
             A mutató típus egyszerű típus, amely tárcímeket tárolhat. Egyik legfontosabb művelete a megcímzett tárterületen elhelyezkedő érték elérése.
        </para>
        <para>A nevesített konstansnak három része van: név, típus, érték és mindig deklarálni kell, ennek értéke ekkor eldől és nem változtatható meg.
        A változónak négy része van? név, attribútumok, cím, érték.A név egy azonosító. Az attribútum a típusa és deklarációval kap értéket, amely változtatható a program futása során.
        Mindaddig amíg nincs értéke, addig határozatlan, tehát nem használható fel. Explicit vagy automatikus deklaráció lehetséges. Előbbi esetén a programozó végzi a deklarációt, utóbbi esetben
        pedig a fordítóprogram rendel attribútumot azokhoz a változókhoz amelyek nincsenek explicit módon megadva, deklarálva. A változóhoz cím rendelhető két féle módon:
        dinamukus tárkiosztás: a futás előtt eldől a változó címe és futás alatt ez nem változik. Dinamikus tárkiosztás esetén a rendszer végzi a cím hozzásrendelést.
        </para>
        <para>
            A C nyelvnek vannak aritmetikai és származtatott típusai. Az aritmetikai típusokhoz tartoznak az integrális típusok: egész(int,short,long), karakter(char),felsorolásos és 
            valós(float, double, long double). A származtatott típusokhoz tartozik a tömb, függény, mutató, struktúra, union és vannak a void típusok. Az aritmetikai típusok
            az egyszerű, a származtatottak pedig az összetett típusok. Nincs logikai típus. A hamis az int 0, minde más inthez rendelt érték igaznak minősül. Az unsigned típusminősítő nem előjeles ábrázolást, a signed pedig előjeles ábrázolást jelöl.
            A struktúra egy fix szerkezetú rekord. A void típus tartománya üres,nincsenek műveletei. A const megagásával nevesített konstanst deklarálunk. Saját típus definiáláshoz TYPEDEF-el lehetséges, de ez csak a típus nevét adja meg nem hoz létre új típust.
            Struktúra deklarásása STRUCT-al lehetésges, union pedig UNION-nal. A C csak egydimenziós tömböket kezel. Deklaráláshoz az indexek darabszámát kell megadni, ami 0-tól darabszám-1-ig fut. A C a tömböt mutató típusként kezeli. A tömb neve a tömb első elemét címzi.
            Van automatikus deklaráció, int egész típus lesz ha egy névhez nem adunk visszatérésí típust.
        </para>
        <para>Kifejezések</para>
        <para>
            A Kifejezések szintaktikai eszközök. A kövekező összetevőkből áll: operandusok, operátorok, kerek zárójelek.
            Az operandus literál, nevesített konstans, változó vagy függvényhívás lehet. Az értéket képviseli. Az operátorok
            műveleti jelek. A kerek zárójelek pedig a műveletek végrehajtási sorrendjét befolyásolják. Redundánsan alkalmazható.
            Alakjuk lehet prefix, az operátor az operandusok előtt állnnak(* 3 5), infix(3 * 5) és postfix(3 5 *). A kifejetés kiértékelése történhez balról-jobbra, jobbról-balra vagy 
            balról-jobbra a predencia táblázat figyelembevételével, az operátorok erősségének figyelembevételével. Zárójelek használatával a predenciatáblázat szerinti végrehajtási sorrendet felül lehet írni.
            Logikai operátorok esetén, pl és művelet esetén, úgy is eldőlhet a kifejezés értéke, hogy nem végezzük el az összes műveletet, ez a rövidzár kiértékelés. 
            A kifejetés típusának meghatározásánál kétféle elvet követnek a nyelvek: típsuegyenértékűséget és típuskényszerítést.
            Az előbbi esetén egy kifejezésben egy kétoperandusú operátornak csak azonos típusú operandusai lehetnek. Az utóbbi esetben azonban
            két különbőző típusú operandusai lehetnek egy kétoperandusú operátornak. A műveletek viszont csak az azonos belső ábrázolású operandusok között végezhetők el 
            különböző típusú operandusok esetén konverzió van.
            A c kifejezésorientált nyelv és a típuskényszerítést elvét vallja. A mutató típusú tartományának elemeivel összeadás és kivonás végezhető.
        </para>
        <para>Utasítások</para>
        <para>Az utasítások segítségével generálja a fordítóprogram a tárgyprogramot. Két nagy csoportja van: deklarációs és végrehajtható utasítások
              A deklarációs utasítás a fordítóprogramnak szólnak, valamilyen szolgáltatást kérnek, üzemmódot állítanak be, információt szolgáltatnak a tárgykód generáláshoz.
              A végrehajtható utasításokból készül a tárgykód, ezeket az alábbiak szerint csoportosítjuk: Értékadó utasítás, üres utasítás, ugró, elágaztató, 
            ciklusszervező, hívó, vezérlésátadó, I/O utasítások és egyéb utasítások.
            Az értékadó utasítás feladata beállítani vagy módosítani egy változó értékét. Az üres utasítás hatására a CPU egy üres gépi utasítást hajt végre. Pl continue, null.
            Az ugró utasítás átadjuk a vezérlést egy adott pontról egy adott cimkével elátott utasításra. Ez a GOTO.
            Elágaztató utasítások közé tartotik a feltéletes utasítás ami kétriányú, ami arra szolgál, hogy a program két tevékenység közül válasszon. If, else.
            A többirányú elágaztató utasítés C-ben a switch(kifejezés) case (feltétel) : (tevékenység). Ez arra szolgál, hogy a program kölcsönösen kizáró akárhány tevékenység közül egyet végrehajtsunk.
            A ciklusszervező utasítások lehetővé teszik, hogy a program egy bizonyos tevékenységet akárhányszor megismételjen.
            Két szélsőséges eset amikor egyszerm sem fut le, ami az üres ciklus és a másik, hogy soha nem áll le, ez a végtelen ciklus. A feltételes ciklus egy feltétel teljesülése szerint
            ismétlődik. A ciklusok fajtái: Kezdőfeltételes(while). Végfeltételes( do utasítás while(feltétel)), előírt lépésszámú(for). A végtelen ciklusból szabályosan a break utasítással tudnunk kilépni.
            A continue vezérlő utasítás a ciklus magjában alkalmazható. A ciklus hátralevő utasításai nem hajta végre, hanem az ismétlődés feltételeit vizsgálja meg és vagy újabb cikluslépésbe kezd, 
            vagy befejezi a ciklust. A reuturn[kifejezés] pedig szabályosan befejezteti a függévényt és visszaadja a vezérlést a hívónak.
        
         </para>

        <para>A programok szerkezete</para>
        <para>
            A program szövege programegységekre tagolható. Az alábbi porgramegységek léteznek: alprogram, blokk, csomag, taszk.
            Az alprogram az eljárásorientált nyelvekben a procedurális absztrakció első megjenenési formája. Az alprogram az újrafelhasználás 
            eszköze. Csak egyszer kell megírni és a programrész azon pontjain, ahol szerepelne, csak hivatkozni kell rá. Ezt formális paraméterekkel 
            látjuk el, általánosabban írjuk meg az újrafelhasználás érdekében. Az alprogram a felépítése: név, formális paraméter lista, törzs, környezet.
            A név egy azonosító, a formális paraméter is a fej része, amiven a azonosítók szerepelnek és ezek a törzsben saját programozási eszközök nevei lehetnek és egy általános 
            szerepkört írnak le, amit a hívás helyén kell konkretizálni az aktuális paraméterek megadásával. A törzsben deklarációs és végrehajtható utítások szereplnek.
            Az alprogramban lokális eszközök vannak, ami kívűlről nem látható, érhető el, viszont a törzsben hivatkozhatunk globális nevekre.
            A környezet globális változók együttese. Az alprogramnak két fajtája van: eljárás és függvény. Az eljárás egy tevékenységet hajt végre, és ennek eredményét használjuk fel. 
            A függvény pedig egyetlen értéket határoz meg, rendelkeznie kell visszatérési értékkel. A függvény mellékhatásának nevezzük, azt ha megváltoztatja környezetét, paramétereit.
            Az eljárás szabályosan befejeződök, ha elértük a végét vagy külön utasítással, pl goto utasítással ki lehet lépni a megadott cimkén folytatva a programot. 
            A visszatérési értéket külön utasítás adja vissza, amely egyben be is fejezteti a függvényt. A függvény, csak akkor fejeződök be szabályosan ha ad visszatérési értéket. 
            A goto utasítás függvény esetében szabálytanak befejeződést jelent. Egy programegységek meghívhat egy másikat és az egy újabbat és így tovább, ez nevezzük 
            hívási láncnak. A hívási lánc első tagja mindig a főprogram. A legutoljára meghívott programegység fejezi be legelőször a működés és a vezérlés visszatér az őt megelőző 
            programegységbe. Azt amikor egy aktív alprogramot hívunk meg rekurziónak nevezünk. Ez lehet közvetlen, amikor egy alprogram önmagát 
            hívja meg és közvetett amikor a hívási láncban már a korábban szereplő alprogramot hívjuk meg. Egyes nyelvek esetén egy alprogramnak meg lehet adni mádsodlagos belépési pontot, tehát 
            nem csak a fejen keresztül lehet meghívni. Paraméterkiértékelésnek nevezzük azt a folyamatot, amikor amikor egy alprogram hívásánál egymáshoz
            rendelődnek a formális és aktuális paraméterek, és meghatározódnak azok az információk, amelyek a paraméterátadásnál a kommunikációt szolgáltatják. 
            A blokk olyan programegység, amely csak a másik programegység belsejében helyezkedhet el, külső szinten nem állhat. A blokknak van kezdete, törzse és vége. A kezdetet és véget egy speciális karaktersorozat 
            vagy alapszó jelzi, a törzsben lehetnek deklarációs és végrehajtható utasítások. A blokknak nincs paramétere és bárhol elhelyezhető. Aktivizálni úgy lehet a blokkot, hogy 
            rákerül a vezérlés vagy GOTO urasítással ráugrunk a kezdetére. 
        </para>

        <para>Paraméterkiértékelés</para>
        <para>
            Paraméterkiértékelés az a folyamat, amikor egy alprogram hívásánál egymáshoz rendelődnek a formális és aktuális 
            paraméterek. A formális paraméterlista az elsődleges, az alprogram specifikációját tartalmazza,csak egy darad van belőle.
            Az aktuális paraméterlistából annyi lehet ahányszor meghívjuk az alprogramot. Tehát mindig az aktuális paramétereket rendeljük a 
            formálisakhoz. Ennek két típusa van: sorrendi és név szerinti kötés. A sorrendi kötés esetén a formális paraméterekhez a felsorolás sorrendjében 
            rendelődnek hozzá az aktuális paraméterek. A név szerinti kötés esetén pedig a paraméterlistában határozhatjuk meg az 
            egymáshoz rendelést. Ezek kombinációja is alkalmazható. Abban az esetben, amikor a formális paraméterek száma fix, ekkor 
            az aktuális paraméterek számának meg kell egyeznie a formális paraméterek számával vagy kevesebb lehet. 
            A típusokról néhány nyelv az típsuegyenértékűséget vallja, ekkor az aktuális paraméter típusának azonosnak kell lennie a formális 
            paraméter típusával vagy létezik a típuskényszerítés elve, ami alapján a paramétertípusok konvertálhatóak.
        </para>
        <para>Paraméterátadás</para>
        <para>
            A paraméterátadásnál van egy hívó, ami tetszóleges programegység és egy hívott, amely egy alprogram. Paraméterátadási módok:
            érték, cím, eredmény, érték-eredmény, név és szöveg szerinti. Érték szerinti átadás esetén, a formális paraméterekek van címkomponensük a hívott
            alprogram területén és az aktuális paraméternek rendelkeznie kell értékkomponenssel a hívó oldalán. A hívott program semmit sem tud a hívóról, 
            a saját területén dolgozik. Az információáramlás egyirányú. Cím szerinti paraméterátadáskor a formális paramétereknek nincs címkomponensük a hívott alprogram 
            területén, aktuális paraméternek viszont rendelkeznie kell. Kiértékeléskor meghatározódik az aktuális paraméter címe és átadódik a hívott 
            programnak. Az információáramlás kétriányú.Az információátadás kétirányú, az alprogram a hívó területérıl átvehet értéket, és írhat is oda.
            Eredmény szerinti átadáskor a kommunikáció egyirányú, a hívottól a hívó felé irányulé és van értékmásolás.
            Érték-eredmény esetén van címkomponens a hivott területen és az aktuális paraméternek rendelkeznie kell érték és címkomponenssel. Kétirányú a kommunikációs, kétszer van 
            értékmásolás. Név szerinti paraméterátadásnál az aktuális paraméter egy szimbólumsorozat lehet. Az információáramlás iránya az aktuális paraméter adott
            szövegkörnyezetbeli értelmezésétıl függ. A szöveg szerinti paraméterátadás a név szerintinek egy változat.
            Alprogramok esetén típust paraméterként átadni nem lehet. Az alpogramok formális paramétereinek három csoportja van:
            input paraméterek, output és input-output paraméterek.
        </para>
        <para>A blokk és hatáskör</para>
        <para>
            A blokk olyan programegység, amely csak másik programegység belsejében helyezkedhet el, külső szinten nem állhat.
            A blokknak van kezdete, törzse és vége. A kezdetet és a véget egy-egy speciális karaktersorozat vagy alapszó jelzi és nincs paramétere. Bárhol elhelyezhető 
            ahol végrehajtható utasítás állhat. A blokkot aktivizálni úgy lehet, hogy rákerül a sor, vagy GOTO utasítással.
            Egy név hatásköre alatt értjük a program szövegének azon részét, ahol az adott név ugyanazt a programozási eszközt hivatkozza.
            A név hatásköre a programegységekhez kapcsolódik. Egy programegységben deklarált nevet a programegység lokális nevének nevezzük. Azt a nevet amely ezen kívűl 
            van deklarálva, de ott hivatkozunk rá, szabad névnek hívjuk. Kétféle határkörkezelés van: statikus és dinamukus. A statikus fordítási időben történik.
            Statikus hatáskörkezelés esetén egy lokális név hatásköre az a programegység, amelyben deklaráltuk és minden olyan programegység, amelyet ez az adott programegység tartalmaz.
            A hatáskör csak befelé terjed. Az a név amely nem lokális név, de az adott programegységben látható, globális névnek hívjuk.
            Dinamikus hatáskörkezelésnél egy név hatásköre az a programegység, amelyben deklaráltuk és minden olyan programegység, amely ezen programegységbıl induló hívási láncban
            helyezkedik el.Statikus hatáskörkezelés esetén a programban szereplı összes név hatásköre a forrásszöveg alapján egyértelműen megállapítható. Dinamikus hatáskörkezelésnél viszont a hatáskör futási 
            időben változhat.
        </para>
        <para>Input/Output</para>
        <para>
            Az I/O platform, operációs rendszer és implementációfüggő. A perifériákkal való kommunikációért felelős, amely az operatív tárból 
            odaküld vagy onnan vár adatot. Középpontában az állomány áll. Van fizikai állomány és logikai állomány. Funkciói szerint input állomány, amelyből csak olvasni 
            lehet. Output állomány amelybe csak írni lehet. Input-output állomány amelybe írni és olvasni is lehet, ezért tartalma változik.
            Létezik formátumos modú, szerkesztett és listázott módú adatátvitel. Bináris adatátvitelkor az adatok a tárban és a periférián
            ugyanúgy jelennek meg.  Programban állománnyal való munkához a következőket kell végrejtani:
            Deklaráció, összerendelés, állomány megnyitás, feldolgozás és lezárás. Összerendeléskor a logika állományt egy fizikai állománnyal feleltetjük meg.
            Lezáráskor pedig ez kapcsolat megszűnik. Implicit állománynak hívjuk azt, amikor a programozó az írás olvasást úgy kezeli, hogy az közveltenül valamelyik perifériával 
            történik. Ebben az esetben az állományt nem kell deklarálni, összerendelni, megnyitni és lezárni, mindezt futtató rendszer automatikusan kezeli.
            C nyelvben az I/O eszközrendszer nem része a nyelvnek, hanem könyvtári függvények állnak rendelkezésre. Ezek a függvények minimum egy karakter illetve egy bájt írását, olvasását 
            teszik lehetővé.
        </para>

    </section>        
    <section>
        <title>Programozás bevezetés</title>
        <para>                
            <citation>KERNIGHANRITCHIE</citation>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
        </para> 
         <para>Vezérlési szerkezetek</para>
            <para> 
                A kifejezések utasítássá válnak, ha pontosvessző követi őket. C-ben a pontosvessző utasítás lezáró jel és nem 
                elválasztó szimbólum. A kapcsos zárójelek közé pedig deklarációkat és utasításokat egyetlen blokkba foghatunk össze. Ez egyetlen utasítással lesz egenyértékű. 
                Az if-else utasítással döntést, választást írunk le. A switch utasítás a többirányú programelágaztatás egyik eszköze. A switch kiértékeli a 
                zárojelek közötti kifejezést és összehasonlítja az összes esettel(case). Ha valamelyik case azonos a kifejezés értékével, akkor a végrehajtás ennél kezdődik. Ha nincs egyező eset 
                akkor a default cimkével elátott case kerül végrehajtásra. Mivel case-ek cimkeként működnek, miután végrehajtódott, a következő case-re ugrik ezért gondoskodin kell a 
                kilépésről break utasítással.
                A while utasítás fejével található utasítás kiértékelésre kerül és ha az értéke nem 0, akkor végrehajtja az utasítást, majd újra kiértékeli a kifejezést, addig amíg 0 nem lesz és véget és a végrehajtás. 
                A for utasítás ugyanígy működik, csak 1 helyett 3 kifejezést kell megadni. Az első és 3. kifejetés értékadás vagy függvényhívás. A 2. pedig relációs kifejezés. 
                A do-while utasítás ciklusban a kiugrási feltétel teljesülését nem a ciklus elején, hanem a végén vizsgálja a ciklustörzs végrehajtása után. A törzs tehát legalább egyszer végrehajtódik.
                A break utasítással a vizsgálat előtt is ki lehet ugrani a ciklusból hasonlóan a switch-ből. 
                A continue utasítás a break-hez kapcsolódik és a ciklus következő iterációjának megkezdését idézi elő. A while és a do esetében ez azt jelenti, hogy azonnal végrehajtódik a felté telvizsgálat, 
                a for esetében pedig a vezérlés azonnal az újrainicializálási lépésre kerül.
                A goto utasítással a a vezérlés feltétel nélkül átadható egy cimkét megadva. A címkézett utasítás azonosító: alakú előtagok, amelyek az 
                azonosítót címkeként deklarálják. A címke a goto célpontjaként szolgál. A nulla utasítás alakja pontosvessző, ami hordozhat címkét közvetlenül valamely összetett utasítás előtt, vagy a
                while-hoz hasonló valamelyik ciklusutasítás számára üres ciklustörzset képezhet.
            </para>       
    </section>        
    <section>
        <title>Programozás</title>
        <para>                
            <citation>BMECPP</citation>
        </para>
        <para> A C++ nem objektumorientált tulajdonságai</para>
        <para> 
              A C++ nyelv a C továbbfejlesztett változata.A C nyelv veszélyesebb elemeit cseréli le biztonságosabb megoldásokra
             és átláthatóbb, kényelmesebb szolgáltatásokat tesz lehetővé.
             C++-ban egy egy függvény üres paraméterlistával void függvénynek minősél, C-ben pedig azt hogy tetszőleges számú paraméterrel hívható. 
             A main függvényben nem kötelező a return használata, mivel a fordító automatikusan return 0 jelzőt fordít a kódba. 
             Bevezették a bool típust ami true vagy false értéket vehet fel. Beépített típus lett a wchar_t a több bájtos sztringliterálok 
             definiálására. Minden olyan helyen állhat változódeklaráció, ahol utasítás is állhat. A függvénynevek túlterhelése is megjelent, 
             így lehetőség van azonos függvények létrehozására, amennyiben az argumentumlistájuk különöző. Lehetőség lett arra, hogy a függvények argumentumainak
             alapértelmezett értéket adjunk meg, amennyiben a függvényhíváskor nem adunk meg értéket az argumentumoknak. A C-ben pointerek segítségével 
             kell megoldanunk a függvényparaméterek cím szerinti átadását. Ezt a problémát oldja meg a C++ referenciatípus bevezetése, ami feleslegessé 
             teszi a pointereknek a cím szerinti paraméterátadásban betöltött szerepét. Ekkor csak egy és jelet kell írnunk a paraméter deklalárciójában a név elé.
             Továbbá kihasználva ekkor cím szerint adjuk át az argumentumot, nagyméretű argumentumok esetén teljesítménynövekedés érhető el, ha csak az argumentumok címét adjuk át, és 
             nem másoljuk le őket.
        </para>
        <para>Operátorok és túlterhelésük</para>
        <para>
            A C++ operátoros kifejezései az összeadás, szorzás, kivonás, osztás és egyéb operátorok végzik az adott műveletet.
            Az operátorok kiértékelési sorrendjét szigorú szabályrendszer rögzíti, ezt zárójelekkel befolyásolhatjuk. A szabályrendszert a 
            precedenciatáblázat tartalmazza. Az operátorok olyan speciális nevű függvények, amelyek kiértékelése egy speciális szabályrendszer alapján működik.
            Az operator kulcsszóval adjuk meg, hogy egy speciális függvényről van szó. Mivel a függvénynevek különböző argumentumok esetén túlterhelhetőek, 
            ezért az operátorok neveit is túlterhelhetjük. Ezzel nem az a cél, hogy már bevált operátorok működését megváltoztassuk, hanem hogy az általunk 
            deifinált típusokra is megadhassuk.
        </para>

        <para>
            Az objektumorientáltság alapelvei
        </para>
        <para>
            Az egyik alapelve az egységbe zárás, ahol az adatstruktúra neve osztály, egyfajta kategóriát definiál.
            Az osztálynak lehetnek egyedei, példányai, amit objektumnak nevezünk. Fontos, hogy az objektum vigyázzon a tulajdonságaira, ne tehesse hozzáférhetővé 
            a program többi részéhez. Ezt hívjuk adatrejtésnek. Egy speciális osztály rendelkezik egy általánosabb osztály tulajdonságaival, mivel örökli azokat.
            Továbbá egy speciális osztály objektuma bárhol felhasználható, ahol az általánosé, ezt hívjuk behelyettesíthetőségnek. Létezik a típustámogatás, amely azt jelenti, 
            hogy a definiált típusok, osztályok úgy viselkedhetnek mint a beépített típusok, támogatnak operátorokat és típuskonverziót. Az objektumnak lehetnek nemcsak  
            tagváltozói, hanem tagfüggvényei is, amit metódusoknak is hívunk. Ezeket megadhatjuk osztálydefinícióban, vagy a függvény törzsét osztályon kívül is. Ebben az 
            esetben névütközés fordulhat elő, mivel két különböző osztálynak is lehet ugyanolyan függvénye, ezért ekkor használjuk a hatókör (scope) operátort, ami egy dupla kettőspont
            amit a függvény neve elé írunk és elé a osztály nevét.
        <programlisting language="c"><![CDATA[
int Point::setx(int value)
{
        fuggvenytorzs
}   
        ]]></programlisting>
            A tagfüggvények csak egyetlen példányban jönnek létre a memóriában, ezért hogy tudja a függvény melyik változó adattagjait kell módosítani, van egy láthatatlan 
            első paraméterük a függvényeknek, amely megkapja a módosítandó struktúrát. Az átadás pointeren keresztül működik.
            Az adatrejtéskor a private szó után felsorolt tagváltozók és függvények csak az osztályon belül láthatóak. Ennek ellentéte a public kulcsszó. Ha nincs kiírva egyik sem 
            akkor alapértelmezetten public struktúra esetén, osztály esetén viszont private.
        </para>
        <para>
            A konstruktor egy olyan sepciális tagfüggvény, amelynek neve megegyezik az osztály nevével és automatikusan meghívódik az osztály példányosításakor. 
            A konstruktor építi fel az objektumot, abban az értelemben, hogy a törzsében megadott változókat inicializálja egy alapértelmezett értékre, vagy a paraméterként átadott értékekre.
            A függvénynév túlterhelés műküdik a kontruktornál is, így egyszerre több, különböző paraméterlistájú konstruktort is megadhatunk. Ha nem írunk konstruktort, az osztály automatikusan 
            tartalmaz egy üres konstruktort, amely nem csinál semmit példányosításkor. Viszont ha már írtunk egy konstruktort, akkor csak az általunk megírt konstruktorral lehet példányosítani az osztályt, 
            ebben az esetben nincs üres apalértelmezett konstruktor, hacsak mi nem hozunk létre egy üreset. A destruktor végzi az erőforrások felszabadítását, amely az objektum által van birtokolva.
            A desktruktor egy tagfüggvény, amely egy ~ jellel kezdődik és az osztály neve követi. Ez akkor hívódik meg, ha az objektum megszűnik. C++ ban dinamuks memóriakezelés értehő el , amiért egy operátor 
            a felelős, ez a new. Ez annyit foglal le a memóriában amennyi a változó vagy objektum mérete. A delete operátorral pedig fel tudjuk szabadítani.
             <programlisting language="c++"><![CDATA[
int *p;
p = new int;
*p = 10;
delete p;
        ]]></programlisting>
        Létezik másolókonstruktor, amely egy referenciát vár, amelynek típusa megegyezik az osztály típusával. A másolókonstruktor esetében is inicializáljuk vele az objektumainkat, 
        azonban van egy másik funkciója, a másolás. Ekkor a fordító autmatikusan lemásolja az objektumot bitenként. A fordító tudja az adattagok méretét, memóriacímét és átmásolja.
        A bitenkénti másolást sekély másolásnak nevezzük, amikor pedig dinamikus adattagokat is lemásolunk, az a mély másolás.
        </para>
        <para>
            A tagváltozókat a konstruktorok az inicializálási listájában tudjuk inicializálni. Az argumentumlista zárójelét követően 
            : -t írunk, majd felsoroljuk az inicializálni kívánt tagváltozókat, zárójelben megadva a kezdőértékeket.
        </para>
    <programlisting language="c++"><![CDATA[
    public:
     Point(int nx = 0, int my = 0): x(nx), y(ny)
     {

     }
        ]]></programlisting>
        <para>
            A private és public jelölésen kívül létezik a friend, illetve protected jelölések is.
            Az osztályok a friend kulcsszóval feljogosíthatnak globális függvényeket a védett tagjaikhoz való hozzáférésre. Ezek a friend függvények,így olyan 
            hozzáférési jogaik vannak az osztály tagfüggvényeihez, tagváltozóihoz, mintha az adott osztály tagfüggvényei lennének.
            Léteznek friend osztályok is, ebben az esetben az előzőhez hasonlóan, az osztály egy másik osztályt jogosít fel a védett tagjaihoz való hozzáféréshez.
        </para>
        <para>Statikus tagok</para>
        <para>
             A statikus tagok a adott osztályhoz tartoznak és nem az objektumaihoz.
             Minden objektumra vonatkozóan közös értéket vesznek fel és anélkül is használhatóak, hogy egyetlen objektuma is lenne az osztálynak.
             A statikus változókat nevezhetjük osztályváltozóknak is. Deklarálásához a static kulcsszót kell használni. Azonban ahhoz, hogy
             helyet foglaljunk neki, a változót az osztálydefiníción kívül definiálni kell. Használjuk a hatókör operátort. Továbbá az osztály tagfüggvényein 
             kívül is szükség van a hatókör operátorra.
              <programlisting language="c++"><![CDATA[
                class A{
                    static int a;
                      ...
                };
                
                int A::a = 1;

                printf("%d\n", A::a);
        ]]></programlisting>
        A statikus tagok mellett léteznek a statikus tagfüggvények is. Hasonlóan az előzőhöz, itt is szükség van a hatóköroperátorra.
        Viszont a statikus függvényekből a nem statikus tagváltozók és tagfüggvények nem érhetőek el.
        </para>
    <para>
        Szabványos adatfolyamok
    </para>
    <para>
        Az adatfolyamok bájtok sorozatát jelenti. Két típusa van: input stream és output stream, benemeti, kimeneti adatfolyam.
        <screen>
            <![CDATA[
                input stream jelölése >> operátor
                output stream jelölése << operátor 
        ]]>
        </screen>
        Az istream típusú objektum csak olvasható, míg az ostream osztály példányai csak írható adatfolyamként használható. 
        Beolvasáskor cin, kiíráskor cout szavakat használjuk. Ahhoz, hogy az std:: előtagot elhagyjuk, iostream állomány kell beépíteni.
        <screen>
            <![CDATA[
                int i;
                cout << "Enter az integer" << endl;
                cin >> i;
        ]]>
        </screen>
        Az adatfolyamokat egy bufferrel látják el, mivel ezek összegyűjtik a karaktersorozatokat és több cout kiíratás csak egy rendszerhívással fogja kiírni 
        a képernyőre. Kiürítésére a cout.flush() szolgál. Létezik a cerr objektum is, ami a hibák kiírására szolgál, és nem bufferel.
        Mivel az adatfolyamok objektumok, ezért rendelkeznek állapottal, ezt egy isotate típusú tagváltozó jelzi.
        Ha az állapot failbit jelzésű, akkor ez hibát jelent, pl formátummal kapcsolatos hibák. A badbit fatális hibát jelent, pl adatvesztés. 
        Eofbit esetén az adatfolyam elérte az állomány végét. A goodbit pedig azt jelzi, hogy nem volt hiba. A C++ tartalma string osztályt, amely változtatja a méretét, 
        ha karaktereket fűzűnk hozzá. Ha stringet olvasunk be, akkor használhatjuk az input operátort, azonban ekkor a egy szóköz megállítja az olvasást, ekkor lehet használni az std::getline függvényt.
    </para>

    <para>
        Manipulátorok és formázása
    </para>
    <para>
        Az adatfolyam objektumoknak vannak tagfüggvényeik, amelyekkel beállíthatjuk az állapotát, adatokat olvashatunk, írhatunk stb. Az I/O manipulátor egy adatfolyam-módosító speciális objektum, 
        amelyet a kiviteli és beviteli operátorok argumentumaként alkalmazunk az adatfolyamra.
        Az előre definiált manipulátorok a iomanip állományban találhatóak. Az endl is egy manipulátor, amely egy sor vége karaktert helyez az adatfolyamba és kiüríti a buffert.
        Vannak olyan manipulátorok, amelyeknek van paramétere pl setprecesion és van amelyiknek nincs, az endl.
        Ha több tulajdonságot kell beállítani vagy törölnio, akkor ezeket egy egész típus bitjeinek érdemes megfeleltetni. A jelzőbitek olyan bitek, amelyeket 
        beállíthatunk vagy törölhetünk. Pl az ios::fixed jelzőbit beállítása esetén tizedes tört alakban írhatjuk ki a számokat. Stringek formázására is számos manipulátor áll rendekezésre.
    </para>
    <para>Állománykezelés</para>
    <para>
        A C++ az állománykezeléshez is adatfolyamokat használ. Az ifstream (input file stream), illetve az ofstream (output file stream) osztályok.
        A kétirányú adatfolyamot peddig az fstream osztály végzi. Az állomány megnyitását a konstruktor végzi, lezárását pedig a destruktor.
        A megynitandó állomány nevét a konstruktornak adjuk át, továbbá opcionálisan második paraméterként megadhatók jelzőbitek, amelyekkel formázási beállításokat adhatunk meg.
        Ezeket ios:: előtaggal kell ellátni. konstruktor és destruktoron kívűl létezik külön open és close függvény is. Bizonyos adatfolyamok esetén 
        pozícionálásra is van lehetőség, amelyre különféle tagfüggvény létezik (tell, seek), ezek nem használhatóak cin, cout, cerr és clog esetén.
        Az istream és ostream adatfolyamok megnyitható írásra és olvasásra, az értelmezett műveletek azonban az adatfolyamok mögött lévő buffer típusától függenek.
    </para>
    </section>        
</chapter>                
