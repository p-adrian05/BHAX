<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href ="https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/vegtelen_ciklus">https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/vegtelen_ciklus</link>          
        </para>
        <para>
            Ebben az esetben a következő végtelen ciklus 100%-ban dolgoztat egy magot:
        </para>   
         <programlisting language="c">
   <![CDATA[
        int main()
        {
             while(1){}
             return 0;
        }
   ]]>
        </programlisting>
        
        <para>
            A program fordítása és indítása után a <command>top -p `pgrep -u adrian loop1`</command> parancs beírásakor láthatjuk
            a várt eredményt.
        </para>
        <screen>
  <![CDATA[
  Tasks: 1 total, 1 running, 0 sleeping,   0 stopped,   0 zombie
  %Cpu0: 1,3 us, 0,3 sy, 0,0 ni, 98,0 id, 0,0 wa, 0,0 hi, 0,3 si, 0,0 st
  %Cpu1: 0,3 us, 0,3 sy, 0,0 ni, 99,3 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
  %Cpu2: 100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
  %Cpu3: 1,4 us, 0,0 sy, 0,0 ni, 98,6 id, 0,0 wa,  0,0 hi, 0,0 si, 0,0 st
  KiB Mem: 8025272 total, 4308952 free, 1653004 used, 2063316 buff/cache
  KiB Swap: 3897340 total, 3897340 free, 0 used. 5653664 avail Mem 
            
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
  4134 adrian    20   0    4376    756    692 R 100,0  0,0   1:14.23 loop1  
  ]]>
        </screen>
        
       
        <para>
            
            0% terhelés eléréséhez meg kell hívnunk a <function>sleep(n)</function> metódust ami lelassítja az iterálás sebességét. 
        </para>
        <programlisting language="c">
   <![CDATA[
    int main()
    {
        while(1)
        {
            sleep(1);
        }
        return 0;	
    }
   ]]>
        </programlisting>
         <screen>
  <![CDATA[
 PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 4515 adrian    20   0    4376    816    752 S   0,0  0,0   0:00.00 loop0  
  ]]>
        </screen>
        <para>
            Minden mag 100% terhelését szálasítással lehet megoldani az OpenMP segítségével. 
        </para>
        <programlisting language="c">
   <![CDATA[
#include <omp.h>

    int main()
    {
        #pragma omp parallel
        {
            while(1){}
        }
        return 0;

    }
   ]]>
        </programlisting>
     <para>
         <command>gcc loop_all_cores.c -o loop -fopenmp</command> parancsal fordítjuk le ebben az esetben.
     </para>
      <screen>
  <![CDATA[
  Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombie
%Cpu0:100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu1:100,0 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu2:100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu3:100,0 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st

            
 PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 4914 adrian    20   0   35576   1024    928 R 388,7  0,0   8:00.85 loop  
  ]]>
        </screen>
  
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/val_csere.c">https://github.com/p-adrian05/BHAX/blob/master/textbook_programs/val_csere.c</link> 
        </para>
        <para>
            Két változó értékének felcserélésének legegyszerűbb módja, amikor segédváltozót haszánálunk, amiben ideiglenesen
            eltároljuk az első változó értékét, majd az elsőt egyenlővé tesszük a másodikkal és a másodikat a segédváltozóval.
            Azonban léteznek módszerek segédváltozó nélküli cserére is.
        </para>
        
        <para>
            Ebben az esetben segédváltozó nélkül cseréljük meg két változó értékét a különbségük kihasználásával.
        </para>
        
         <programlisting language="c">
   <![CDATA[
#include<stdio.h>

int main()
{
		int a = 3;
		int b = 8;

		//segedvaltozo nelkül
    b = b-a;
		a = a+b;
		b = a-b;
		printf("a=%d b=%d\n",a,b);
   ]]>
        </programlisting>
        
        <para>
            A következő módszer pedig az EXOR-os csere.
        </para>
         <programlisting language="c">
   <![CDATA[
#include<stdio.h>

int main()
{
		int a = 3;
		int b = 8;

		//exorra
		//kettes számrendszerben:
		//a = 8-> 0001
		//b = 3-> 1100
		
		a = a^b; //1101
		b = a^b; //0001
		a = a^b; //1100
		
		printf("a=%d b=%d\n",a,b);
   ]]>
        </programlisting>
        
        
        
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href ="https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/labda">https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/labda</link>
        </para>
        <para>
            A labdapattogás nevű feladat klasszikus megoldása feltételvizsgálatokkal történik, ahol nyilvántartjuk a terminál méretét
            (fordításkor <command>-lncurses</command> könyvtár használatával), a labda koordinátáinak kezdőértékét és lépések mértékét. 
            Ezután if feltételvizsgálattal nézzük, hogy ha elérte az egyik oldalt a labda, akkor változtatjuk a lépések irányát. Használjuk még a
            <command>usleep(n)</command> metódust aminek segítségével lassítjuk a labda mozgását és a <command>clear()</command> metódussal pedig
            csak 1 labdát fogunk látni,mivel minden egyes iterációnál törli a ablakot.
            Azonban if nélkül is megoldható a feladat:
        </para>
        
        <programlisting language="c++">
   <![CDATA[
#include <iostream>
#include <vector>
#include <unistd.h>
using namespace std;

const int szelesseg = 40;//ablak szelesseg
const int magassag = 20;//ablak magassag
int x=1, y=1; //labda kezdoertek
int deltax=1,deltay=1; // hanyasaval lepkedjen
vector<int> ablakx;
vector<int> ablaky;

void kirajzol();
void mozgatas(){
	x=x+deltax;
	y=y+deltay;
	deltax=deltax*ablakx[x];
	deltay=deltay*ablaky[y];
}

int main(){

    for (int i=0; i<szelesseg; i++)
    {
         ablakx.push_back(1);
    }

    for (int i=0; i<magassag; i++)
    {
        ablaky.push_back(1);
    }

    ablakx[0]=-1;//bal oldal
    ablakx[szelesseg-1]=-1; // jobb oldal
    ablaky[0]=-1; //teteje
    ablaky[magassag]=-1; // alja

    for(;;)
    {
        kirajzol();
        mozgatas();
        usleep(100000);
    }

}
   ]]>
        </programlisting>
        
        <para>
            A fenti program C++-ban van megírva. Hasonlóan az if-es megoldáshoz itt is rögzítjük a kezdőértékeket. Ebben az esetben nem saját
            ablakot rajzolunk ki, hogy lássunk ilyet is ,aminek előre meghatározzuk a magasságát és szélességét. A <command>kirajzol()</command>
            metódus keretet rajzol ki, amiben majd pattog a labda, más dolga nincs. A <command>main()</command> metódusban az ablakunk x és y szélességével
            töltjük fel a két vektort. Ezután beállítjuk -1 értékre a vektorok két elemét, hogy a <command>mozgatas()</command> 
            metódusban megszorozzuk a labda lépéseinek nagyságát (ami egyben az irányért is felelős) az oldalak értékeivel. Ha -1-el szorzunk, akkor
            ez az jelenti, hogy elérte az egyik oldalt és változtatjuk az irányt, hasonlóan az if-es megoldásnál, ahol ugyanez ifekkel történt.
            
        </para>

    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
        
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokából képzett összege konvergál egy számhoz. Ezt határt 
            Brun konstansnak nevezzük. Ezzel ellentétben a prímszámok a végtelen felé tartanak.
        </para>
        <para>
            Mik azok a prímszámok?
        </para>
        <para>
            A prímszám olyan természetes szám, ami csak önmagával és eggyel osztható és minden természetes szám előállítható prímszámok
            szorzataként. Ikerprímek pedig azok a prímszámok, amelyek egymás után következnek és különbségük 2.
        </para>
        <para>
            A Brun tétel szimulációja a matematikai R nyelvben lesz megírva, használva a matlab csomagot a prímszámok számítására.
        </para> 
         <programlisting language="R">
<![CDATA[

sumTwinPrimes <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = sumTwinPrimes)
plot(x,y,type="b")
]]>
        </programlisting>  
        
        <para>
            Létrehozunk egy függvényt aminek paraméterként átadjuk, hogy meddig számolja függvényünk az ikerprímszámokat.
            A primes vektorba kiszámoljuk a <command>primes(x)</command> fügvénnyel a prímszámokat.
            A diff vektorban eltároljuk az egymásután következő prímszámok különbségét.
            Az idx vektorban, pedig azokat a helyeket tároljuk, el ahol a különség 2, tehát ikerprímek találhatóak ott.
            A t1primes vektorban elátároljuk az ikerprímek első párját, a t2primes-ban pedig hozzáadva minden első párhoz kettőt,
            az ikerprímek második párját is.
            Az rt1plust2 vektorban tároljuk minden párnak a reciprokainak az összegét, majd ezeket az összegeket <command>sum()</command> függvénnyel
            összeadjuk és visszaadjuk ezt az értéket. 
        </para>
        <para>
            Ezután kirajzoltatjuk és láthatjuk, hogy valóban egy felső határhoz konvergálnak az összegek.
        </para>
        
<figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50" />
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>       


        
        
        
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>                
