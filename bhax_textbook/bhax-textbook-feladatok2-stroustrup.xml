<chapter xmlns="http://docbook.org/ns/docbook" 
  xmlns:xlink="http://www.w3.org/1999/xlink" 
  xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
  <info>
    <title>Helló, Stroustrup!</title>
    <keywordset>
      <keyword/>
    </keywordset>
  </info>
  <section>
    <title>JDK osztályok</title>
    <para>
       Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes
osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
    </para>

    <para>
            Megoldás forrása:
    </para>
    <para>
    </para>
    <programlisting language="C++">
      <![CDATA[ 
#include <iostream>
#include <string>
#include <fstream>
#include <boost/filesystem.hpp>

void readClasses(String path,std::vector<string> &classes);
int main(int argc, char *argv[]){

std::string path;
  std::vector<string> classes; if(argc==1){
         path = argv[0];
         readClasses(path,&classes);
    }
    

    for(int i = 0;i<classes.size();i++)
    {
        std::cout<<classes[i] <<"\n"<<;
    }


}

void readClasses ( boost::filesystem::path path, std::vector<string> &classes )
{

        if ( is_regular_file ( path ) ) {

                std::string ext ( ".java" );
                if ( !ext.compare ( boost::filesystem::extension ( path ) ) ) {

                        classes.push_back(path.string());
                }

        } else if ( is_directory ( path ) )
                for ( boost::filesystem::directory_entry & entry : boost::filesystem::directory_iterator ( path ) )
                        readClasses ( entry.path(), classes );

}
]]>
    </programlisting>



  </section>
  <section>
    <title>Másoló-mozgató szemantika</title>
    <para>
            Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató
szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra!  
    </para>
    <para>
          Megoldás forrása:   
    </para>
    <para>
    Másoló konstruktor akkor kerül meghívásra C++ esetén, ha inicializálatlan objektumhoz értéket rendelünk. Gyakran van szükség 
    több példányra ugyanabból az objektumból, ekkor szükséges a másoló konstruktor. Ha nem adunk meg saját másoló konstruktort, akkor 
    automatikusan keletkezik egy, ami csak egyszerűen lemásolja a nem statikus adattagokat, ezt hívjuk shallow copynak. Ha az adott osztályunk mutatókat vagy 
    referenciákat tartalmaz, ez az alapértelmezett másoló konstruktor nem megfelelő, mert nem a mutatott adatokat, hanem a mutatót magát másolja át.
    Továbbá a másoló konstruktor paramétere az osztály egy objektumára vonatkozó referencia kell, hogy legyen, különben végtelen ciklus keletkezik, mert 
    a paraméterátadáshoz is a másoló konstruktort használjuk. A másoló konstruktor hívódik meg az alábbi esetekben: 
    változó kezdeti értékének beállításakor, nem referencia  függvényparaméter átadásakor, függvény nem referenciával visszatérésekor és kivétel dobásánál és 
    elkapásánál. A másoló konstruktor és az értékadó operátor lehet private elérésű, ekkor az osztály objektumai nem hozhatóak létre és nem 
    másolhatóak, de az osztály publikus tagfüggvényei így is elérik őket. A másoló értékadás pedig akkor kerül meghívásra, ha már egy 
    létező objektumnak akarunk egy olyan új értéket adni, ami egy már létező másik objektum.
    </para>

    <para>
         Példaként a binfa másoló konstruktora, ami meghívásra kerül, amikor egy új binfa objektumot hozunk létre a régiből, ami egy másolata az eredetinek.
         A másoló konstruktorba referenciaként kapjuk a régi, lemásolandó objektumot. Ezután a régi fa minden csomópontjának értékén végig megyünk, hogy beállítsuk
         az új fa csomópontjait, ez a másol függvényben kerül sorra. Pontosan ugyanaz a fa lesz kiépítve az új binfába, mint a régibe ami úgy történik, hogy egyszerűen 
         megyünk végig a régi fa csomópontjain és közben állítjuk be az új fa értékeit, a régi fa értékeivel. Az ujelem mutató mutat az aktuálisan lemásolt csomópontra,
         ,ami ha egyenlő az aktuális régi fa csomópontjával akkor beállítjuk az új fa aktuális csomópontjának. Másoló értékadáskor (operator=) pedig 
         visszaadjuk arra az objektumra való mutatót, amire mutatni fog az átállítandó objektum. Példaként a binfa2 a binfa4-re fog mutatni.
    </para>

    <programlisting language="c++">
      <![CDATA[ 

    //Másoló konstruktor
 LZWBinFa ( const LZWBinFa & regi ) {
          std::cout << "LZWBinFa copy ctor" << std::endl;

          gyoker = masol(regi.gyoker,regi.fa);
     }
Csomopont *  masol ( Csomopont * elem, Csomopont * regifa ) {

          Csomopont * ujelem = NULL;

          if ( elem != NULL ) {
               ujelem = new Csomopont ( elem->getBetu() );

               ujelem->ujEgyesGyermek ( masol ( elem->egyesGyermek (), regifa ) );
               ujelem->ujNullasGyermek ( masol ( elem->nullasGyermek (), regifa ) );

               if ( regifa == elem )
                    fa = ujelem;

          }

          return ujelem;
     }
    //Másoló értékadás
     LZWBinFa &operator=(LZWBinFa &fa)
     {
          std::cout << "LZWBinFa copy assign" << std::endl;

          return *this;
     }

]]>
    </programlisting>

    <programlisting language="c++">
      <![CDATA[ 
int
main ( int argc, char *argv[] )
{

LZWBinFa binFa;
//masolo konstruktor
LZWBinFa binFa2 =  binFa;  
LZWBinFa binFa4 = binFa;
//masolo ertekadas
binFa2 = binFa4;

]]>
    </programlisting>


  </section>

  <section>
    <title>Hibásan implementált RSA törése</title>
    <para>
			Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló:
https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71-73 fólia) által
készített titkos szövegen.
    </para>
    <para>
          Megoldás forrása:  
    </para>
    <para>

    </para>

  </section>
  <section>
    <title>Változó argumentumszámú ctor</title>
    <para>
			Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére
és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű „képet” adjon vissza. (Lásd még a 4
hét/Perceptron osztály feladatot is.)
    </para>
    <para>
          Megoldás forrása:  
    </para>

    <para>
    A Perceptron egy neurális háló, aminek csomópontjai vannak. A csomópontok a mesterséges neuronok. Két fő csomópont a bemeneti és kimeneti csomópontok. Van egy központi csúcs is, ahol a 
    számolás történik. Az input csúcsokból bejövő kapcsolatok súlyozva vannak, ami alapján történik a számolás a központi csúcsban. A tanulás abból áll, hogy a bejövő kapcsolatok erőssége változik, 
    a sokat használt kapcsolatokban erősödik, a ritkán használtakban gyengül. Egy neurális hálózat esetén pedig több réteg lehet egymás után, amik a perceptronok és minden perceptron az eggyel korábbi 
    szinten lévőkből kapja az inputot és az eggyel későbbi szintre továbbítja.
    </para>

    <programlisting language="C++">
      <![CDATA[ 
#include <iostream>
#include "mlp.hpp"
#include "png++/png.hpp"

int main(int argc, char **argv)
{
    png::image<png::rgb_pixel> png_image(argv[1]);
    int size = png_image.get_width() * png_image.get_height();

    Perceptron *p = new Perceptron(3, size, 256, size);

    double *image = new double[size];

    for (int i{0}; i < png_image.get_width(); ++i)
        for (int j{0}; j < png_image.get_height(); ++j)
            image[i * png_image.get_width() + j] = png_image[i][j].red;

    double *newImage = new double[size];
    *newImage = (*p)(image);

    for (int i{0}; i < png_image.get_width(); ++i)
        for (int j{0}; j < png_image.get_height(); ++j)
            png_image[i][j].red = newImage[i * png_image.get_width() + j];

    png_image.write("newMandel.png");

    delete p;
    delete[] image;
    delete[] newImage;
}
]]>
    </programlisting>
    <para>
         Ebben a projektben használjuk a Perceptron osztályt. A mandel program által előállított kép lesz feldolgozva.
         Először eltároljuk png::image objektumként a paraméterként kapott képet. A size változóban a kép méretét tároljuk el. Ezután létrehozzuk a 
         perceptron objektumot, mutatóját megadva a konstruktorának a paramétereket, ami változó paraméter számú. A 3 a neurális háló rétegek számát jelenti, a size a kép mérete, a 256 a neuronok száma az egyes 
         rétegekben, ellentétben az előző perceptron feladatban, most nem 1 hanem 256 kimeneti neuront adunk meg, ezáltal egy ugyanakkora képet kapunk vissza.
          Lefoglaljuk az új kép méretének, pixeleinek a helyét egy double tömbre mutató mutatóval, ami az eredi kép összes pixelét képes tárolni.
         Ezután két for ciklussal bejárjuk az eredeti képet, pixeleit és az új helyre tesszük az eredeti kép piros komponenseit.
         Miután megvan a kép, meghívjuk a perceptron osztály () operátorát átadva azt a tömböt amiben az eredeti kép pixelei vannak, ami most nem egy double típusú értéket ad vissza, hanem egy double értékeket tároló tömböt, aminek értékeivel módosítjuk 
         az eredeti kép pixeleit. Két for ciklussal szintén végigjárunk a pixeleken és most az eredeti kép piros komponenseit cseréljük ki azokra az értékekre, amit kaptunk perceptron osztálytól.
         Végül az elkészült képet kimentjük és felszabadítjuk a memóriát.
    </para>
    <mediaobject>
      <imageobject>
        <imagedata fileref="img/mandel.png" scale="40" />
      </imageobject>
    </mediaobject>
    <mediaobject>
      <imageobject>
        <imagedata fileref="img/percep2.jpg" scale="80" />
      </imageobject>
    </mediaobject>

    <mediaobject>
      <imageobject>
        <imagedata fileref="img/newMandel.png" scale="40" />
      </imageobject>
    </mediaobject>

  </section>

  <section>
    <title>Összefoglaló</title>
    <para>
         Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „”esszé szöveget!
    </para>
    <para>
          Megoldás forrása:  
    </para>

    <para>

    </para>

  </section>
</chapter>   