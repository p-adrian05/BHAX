<chapter xmlns="http://docbook.org/ns/docbook" 
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Berners-Lee!</title>
    </info>

    <para>C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++ nyelven</para>
    <para>Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0 I-II.</para>
    <para>Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba. Gyors prototípus-fejlesztés Python és Java nyelven (35-51 oldal)</para>


    <section>
        <title>1.hét Az objektumorientált paradigma alapfoglamai.</title>
        <para>Osztály,objektum, példányosítás.</para>
        <para>
            Egy osztály azonos típusú dolgok modelljét írja le. A dolgok lehetnek a létező világ objektumai vagy 
            programok belső világához tartozó absztrakt objektumok is, például adatszerkezetek.
            Működés során az osztályokat példányosítjuk, objektumot hozunk létre, egy osztályból többet is. 
            Az objektum saját állapottal rendelkezik, ami műveletek hatására változhat.
            Az osztályokat két részből álló osztálydefiníció határozza meg. Az egyik rész deklarálja az objektum állapotát leíró változókat, 
            amiket példányváltozónak nevezünk. A másik rész pedig a metódusokat, függvényeket tartalmazza, amik az objektum viselkedését, 
            műveleteit határozza meg. A metódus meghívásakor meg kell adni melyik objektumra szeretnénk meghívni.
            Az objektumok fontos tulajdonsága az adatok elrejtése más osztályok, objektumok elől és az egységbezárás amit együtt
            adatabsztrakciónak nevezünk.
            Az objektum példányosítása a new operátorral történik meg. Ezzel memóriát foglal le az objektum és tartalma részére és visszaadja ezen tárterület
            kezdőcímét. Ezt a referenciát egy megfelelő osztály típusú változónak adhatjuk értékül. A referencia abban különbözik a C++ esetén lévő mutatótól, hogy a mutatott objektumot jelenti, nem pedig a címét.
             C++ esetén a delete operátorral ezt helyet tudjuk felszabadítani, java esetén erre nincs szükség mivel a JVM-ben található Garbage Collector felszabadítja 
            automatikusan azokat az objektumokat amire már nem hivatkozik semmi. A konstruktor pedig egy olyan sepciális tagfüggvény, amelynek neve megegyezik az osztály nevével és automatikusan
            meghívódik az osztály példányosításakor. A konstruktor építi fel az objektumot, abban az értelemben,
            hogy a törzsében megadott változókat inicializálja egy alapértelmezett értékre, vagy a paraméterként átadott értékekre.

        </para>
    </section>
    <section>
        <title>2.hét Öröklődés, osztályhierarchia.</title>
        <para>Polimorfizmus, metódustúlterhelés, hatáskörkezelés, a bezárási eszközrendszer, láthatósági szintek, absztrakt osztályok és interfészek. </para>

        <para>
            Az öröklődés legegyszerűbb esete, amikor egy osztályt egy már létező osztály kiterjesztésével definiálunk.
            A kiterjesztés jelentheti új műveletek és új változók bevezetését. Az eredeti osztályt szülőosztálynak nevezzük, a bővítettet pedig gyermekosztálynak. A gyermek örököl mindent a szülőosztálytól, amit a szülő megenged.
            Az öröklődés révén kódmegosztás jön létre, ezáltal csökken a kód redundanciája.Amikor felülírja a gyermekosztály a szülő függvényét Java esetén egy @Override annotációt kell a függvény fölé írni, C++ esetén pedig a virtual kulcsszót.
            Mivel a gyermek őseinek minden változójával és metódusával bír, minden környezetben használható, ahol ősei is, ezt nevezzük polimorfizmusnak (többalakúságnak).
            Az osztályok rokonsági viszonyainak összességét osztályhierarchiának hívjuk, amit gyakran mint fentről lefelé növő fát ábrázolnak. Java esetén az Object minden más osztálynak őse.
        </para>
        <para>
            Egy osztályban egy függvény, metódus vagy konstruktor túlterhelhető. Ez azt jelenti, hogy ugyanazon a névvel létrehozhatunk többet is belőlük, viszont fontos hogy paramétereik száma vagy sorrendje eltérjen.
            Ennek lényege, hogy különböző paramétereket átadva másképp viselkedjen az objektum. Ha nem adunk meg konstruktort az objektumnak, akkor automatikusan létrehoz egy üreset, viszont ha több konstrunktort hozunk létre, akkor kötelező egy 
            üreset is kétrehozni.
        </para>
        <para>
                Az osztály class kulcsszó előtt, az objektumban található függvények, metódusok, változók előtt szerepelhetnek módosítók. A public módosító azt jelenti, hogy az adott osztály hozzáférhető más csomagokhoz is vagy 
                elérhető az adott változó, függvény stb más osztályokból is, ennek ellentetje a private, ami esetén az kiterjesztett osztály sem fér hozzá.
                Private osztály is lehet, viszont csak belső inner osztályként definiálható, mivel csak így van értelme. Protected jelölés azt jelenti, hogy 
                egy osztályt nem lehet példányosítani, csak kiterjeszteni más osztály által és azt példányosítani. Változók, függvények esetén pedig csak azok férhetnek hozzá amelyek kiterjesztik az adott osztályt. C++ esetén létezik friend jelölés is, ekkor az így jelölt osztály 
                hozzáfér annak az osztály private és protected tagjaihoz, amelyik friendként deklarálta. Függvények esetén pedig olyan hozzáférést kapnak, mintha az adott osztály tagfüggvényei lennének.
                Ha pedig az osztály elé nem rakunk semmilyen kulcsszót, Java esetén package-private lesz az osztály, ami azt jelenti hogy csak az adott package-ben férhető hozzá más osztályok által, C++ esetén pedig alapértelmezetten private lesz.
                Változók, függvények esetén pedig alapértelmezetten az osztály módosítóját veszik figyelembe. A konstruktor minden esetben public, ha privatera állítjuk akkor nem lehet példányosítani az osztályt.
        </para>
        <para>
            Az absztrakt osztályok abban különböznek a nem absztrakt osztályoktól, hogy tartalmazhatnak absztrakt metódusokat, de lehetnek hagyományos metódusok is mint egy normális osztálynak. Az osztályhierarchia tetejét alkotó osztályok nagy részének 
            az a szerepe, hogy a leszármazottak interfészének közös metszetét definiálja, mintsem, hogy kész megvalósítást adjon. Ezeket absztrakt osztályoknak hívjuk.
        </para>
        <para>
            Az interfész egy új referencia típus. Az osztályokhoz képest itt hiányoznak metódusok definiálása, implementációi, csak deklarálva vannak. C++ estén nincs konkrétan interface, de ugyanazt az eredményt lehet 
            létrehozni egy absztrakt osztály létrehozásával, amiben minden metódust virtual jelzővel látunk el. Java esetén külön létezik az interface és absztrakt osztály fogalma. 
            Bármennyi interfészt lehet implementálni, de mindig csak 1 osztályt lehet kiterjeszteni. Amikor az osztály implementál egy interfészt, akkor kötelező minden az interfészben megfogalmazott metódust felülírni, implementálni.
            Ezáltal az adott osztály minden olyan helyen használható lesz, ahol az interfész típusa van megadva, ez érvényes az intefészt implementáló osztályt kiterjesztő osztályokra is.
            Az interfész gyakorlatilag egy tulajdonságot biztosít az osztálynak és ez alapján biztosak lehetünk benne az olyan helyeken, ahol csak egy bizonyos tulajdonságú (adott iterface-t implementáló) osztályt kaphatunk.
            Java interfésznél minden metódus automatikusan public és abstract.
        </para>




    </section>
    <section>
        <title>3.hét Modellező eszközök és nyelvek. AZ UML és az UML osztálydiagramja.</title>

        <para>
            Az UML szabványos modellező nyelv. Nagyméretű programrendszerek modelljeinek vizuális dokumentálására alkalmas, ennek segítségével különböző szöveges és grafikus modellek készíthetőek.
            Programok esetén az UML az objektumorientált programozás szabványos specifikációs nyelve. Az UML modellek UML diagramokból állnak. Az osztálydiagram 
            egy statikus modell. A programban használt osztályokat, interfészeket attrubútumaival együtt, ezeknek a kapcsolatait mutatja be.
        </para>

    </section>

    <section>
        <title>A Python nyelv bemutatása</title>
        <para>
           A Python egy általános célú programozási nyelv, amely magas szintű, dinamikus, objektumorientált és platform független.
           Tanulási ciklusa igen rövid, ezért hamar lehet látványos eredményeket elérni vele. A Python tulajdonképpen egy szkriptnyelv, rendkívűl sok csomagot és 
           beépített eljárást tartalmaz, így komolyobb problémák megoldására és összetett alkalmazások készítésére is használható.
           Python esetében nincs szükség fordításra minden mótosítás után. Prototípus alkalmatás készítésére a Python a legalkalmasabb, mivel egyszerű a használata, 
           megbízható és jelentős támogatást biztosít a hibák javítására. A nyelvhez tartozó kódkönyvtárak rengeteg újrahasznosítható modulokat tartalmaznak, amelyek jelentősen 
           meggyorsítják a fejlesztést. Ilyen modulok vannak pl a fájlkezelésre, hálózatkezelésre, rendszerhívásokra, UI kialakítására, ezért tömörebb, rövidebb 
           könyebben olvasható programkód készíthető, mint C,C++ vagy Java nyelven. Ennek okai még a következők: A magas szintű adattípusok lehetővé teszik, hogy 
           összetett kifejezéseket írjunk le rövid állításban, a kódcsoportosítás egyszerű tagolással történik és nincs szükség változó vagy argumentumdefiniálásra.
        </para>
        <para>
         A nyelv fő jellemzője, hogy behúzásalapú a szintaxisa, nincs szükség kapcsos zárójelekre vagy explicit kulcsszavakra. Egy adott blokk végét egy 
         kisebb behúzású sor jelzi. Az utasítások a sor végéig tartanak, nincs szükség a ; használatára. Ha egy utasítás több sorban fér el, akkor a sor végére írt \ jellel lehet jelezni.
         Pythonban minden adatot objektumok reprezentálnak. Az adatokon végezhető műveleteket az objektumok típusa határozza meg. Nincs szükség a változók típusának megadására, futásidőben a rendszer kitalálja a hozzárendelt típust.
         Az adattípusok lehetnek számok, stringek, ennesek, listák, szótárak. Az ennesek objektumok gyűjteményei vesszőbel elválasztva, típusai lehetnek eltérőek is. Ezeket zárójelek közé írjuk.
         A lista különböző elemek rendezett szekvenciája. A szótás kulcsokkal azonosított elemek rendezetlen halmaza. A null értéknek none a neve.
         Boolean típusként bármilyen változó használható.
        </para>
        <para>
            Pythonban változók alatt az egyes objektumokra mutató referenciákat értünk, maguknak a változóknak nincsenek típusai, így akár különböző típusú objektumra is mutathatnak futásidőben. 
            Ha töröljük az utolsó hivatkozást az objektumról, akkor a garbage collector szabadítja fel. Ha egy változót globálisként akarunk kezelni, akkor elég kell írni a global kulcsszót.
            A különböző típusok közötti konverzió is támogatott. Szekvenciákon és szótárakon több beépített függvényt is használhatunk.
        </para>
    </section>
</chapter>                
