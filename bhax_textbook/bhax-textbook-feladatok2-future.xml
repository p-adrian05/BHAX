<chapter xmlns="http://docbook.org/ns/docbook" 
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
         Javítsunk valamit a ActivityEditor.java JavaFX programon! 
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/future/tree/master/cs/F6">https://github.com/nbatfai/future/tree/master/cs/F6</link>

        </para>
        <para>
           A hibásan működő programrész:
        </para>
        <programlisting language="java">
            <![CDATA[ 
             if (f.mkdir()) {
                    javafx.scene.control.TreeItem<java.io.File> newAct

                           = new FileTreeItem(f, new javafx.scene.image.ImageView(actIcon));                            
                    getTreeItem().getChildren().add(newAct);
                } else {

                    System.err.println("Cannot create " + f.getPath());

                }
  
            });
]]>
        </programlisting>
        <para>
           Hibás működés közben:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/rosszjava.png" scale="50" />
            </imageobject>
        </mediaobject>
        <para>
        A TextFieldTreeCell osztály konstruktorában van az Új altevékenység hozzádásának implementálása. A mappára kattintás esetén 
        egy almenü ugrik fel, egy Új altevékenység hozzáadása gomb. Ezt létrehozva, hozzáadjuk a helyi felugró menü elemeihez, majd meghívjuk 
        rajta  az onAction metódust,llambda kifejezést használva, amiben meghatározzuk mi történjen egy esemény,jelen esetben jobb klikk esemény
         bekövetkeztekor. Egy File típusú objektum tárolja majd a 
        kattintott elem értékét. Ezután ennek az elemnek létrehozunk egy új fájlt gyermekeként hozzáadva.
        </para>
        <para>
        A program hibája, hogy csak egy új almappát lehet létrehozni ugyanabba a mappába. Ezt úgy lehet kijavítani, hogy ahelyett hogy egy 
        ugyanolyan nevű mappát hoznánk létre mint az elsőnek létrehozott, egy olyan mappát hozunk létre aminek a neve már különböző az előzőtől, 
        egy sorszámot a végéhez hozzáadva amit mindig növelünk. 
        </para>
        <programlisting language="java">
            <![CDATA[ 
            private int a = 1;

        public TextFieldTreeCell(javafx.scene.control.TextArea propsEdit) {
            this.propsEdit = propsEdit;

            javafx.scene.control.MenuItem subaMenuItem = new javafx.scene.control.MenuItem("Új altevékenység");//"New subactivity");
            addMenu.getItems().add(subaMenuItem);
            subaMenuItem.setOnAction((javafx.event.ActionEvent evt) -> {

                java.io.File file = getTreeItem().getValue();
                java.io.File f = new java.io.File(file.getPath() + System.getProperty("file.separator") + "Új altevékenység");

                if (f.mkdir()) {
                      javafx.scene.control.TreeItem<java.io.File> newAct
                           = new FileTreeItem(f, new javafx.scene.image.ImageView(actIcon));                            
                   getTreeItem().getChildren().add(newAct);
                } else {
                     javafx.scene.control.TreeItem<java.io.File> newAct
                           = new FileTreeItem(f = new java.io.File(file.getPath() + System.getProperty("file.separator") + "Új altevékenység"+" "+ a), new javafx.scene.image.ImageView(actIcon));                            
                   getTreeItem().getChildren().add(newAct);
                   a++;
               }
  
            });
]]>
        </programlisting>
        <mediaobject>
            <imageobject>
                <imagedata fileref="img/jojava.png" scale="50" />
            </imageobject>
        </mediaobject>
    </section>

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title>
        <para>
         Mutassunk rá a scanf szerepére és használatára! 
        </para>
        <para>
            Megoldás forrása:  Megoldás forrása: <link xlink:href="https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll">https://github.com/nbatfai/robocar-emulator/blob/master/justine/rcemu/src/carlexer.ll</link>

        </para>
        <para>
            A scanf függvény bejövő stringek beolvasására, feldolgozására alkalmas. Visszatérési értéke a sikeresen beolvasott változók száma.
            Akkor tér vissza, ha formátumsztring által meghatározott számú adatot beolvasott vagy hibát észlel, azaz az adatbevitel nem felel meg a formátumsztring előírásainak.
        </para>
        <programlisting language="c++">
            <![CDATA[ 
        int sscanf( const char* buffer, const char* format, argumentumlista );
]]>
        </programlisting>

        <para>
            A POS és WS definiált alakja:       
        </para>
        <programlisting language="c++"><![CDATA[ POS  : "<pos" , WS :  [ \t]* ]]></programlisting>

        <programlisting language="c++">
            <![CDATA[ 
        {POS}{WS}{INT}{WS}{INT}{WS}{INT}	{
					                         std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);
					                         m_cmd = 10001;
					                        }
]]>
        </programlisting>

        <para>
        A fenti kifejezés alakja tehát:  
        </para>
        <programlisting language="c++"><![CDATA[ <pos[\t]*{INT}[\t]*{INT}[\t]*{INT} ]]></programlisting>
        <para>
            A reguláris kifejezésekben használt * jelentése bárhányszor előfordulhat, tehát ez a kifejezés azt jelenti, hogy 
            pos-al kell kezdődnie, három darab int érték lehet a szóban és közöttük 0 vagy bármennyi tabulátor. Ha megfelelt a beolvasott 
            string a kifejezésnek, akkor történik a kiértékelés. A scanf függvény első paramétere maga a szöveg, amit a lexer helyesnek 
            talált. A második paraméter a formázása az adatoknak amiket beolvas az m_id, from és to változókba.
        </para>
        <programlisting language="c++">
            <![CDATA[ 
        {INITG}{WS}{WORD}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init guided %s %c>", name, &role);
				  num = 1;
				  m_guided = true;
				  m_cmd = 3;
				}
]]>
        </programlisting>
        <para>
            Ebben a példában annyi újdonság van az előzőhöz képest, hogy a role változóba beolvasott érték kizárólag
            csak "c" vagy "g" érték lehet.
        </para>
        <programlisting language="c++">
            <![CDATA[ 
        {ROUTE}{WS}{INT}{WS}{INT}({WS}{INT})*	{
				  int size{0};
				  int ss{0};
				  int sn{0};				  
				  
				  std::sscanf(yytext, "<route %d %d%n", &size, &m_id, &sn);
				  ss += sn;
				  for(int i{0}; i<size; ++i)
				  {
				    unsigned int u{0u};
				    std::sscanf(yytext+ss, "%u%n", &u, &sn);
				    route.push_back(u);
				    ss += sn; 				    
				  }
				  m_cmd = 101;
				}
]]>
        </programlisting>
        <para>
          A fenti kódrészlet már kicsit összetettebb. A beolvasott szövegnek route-tal kell kezdődnie és legalább két szám áll utána. 
          A size változóban tároljuk a megfelelően illesztett szöveg hosszát, ss-ben az eddig 
          feldolgozott szöveg méretét, sn-ben pedig az aktuálisan feldolgozandó szöveg teljes hosszát. Mivel bármennyi szám következhet az első kettő után, ezért
         for ciklussal kell végigmenni a szón, mindig növelve a teljes méretet(ss) az aktuálisan beolvasott 
          karakterek hosszával (sn). A teljes szó hoszzáig megy a ciklus, lépkedve a karaktereken, mindig hozzáadva a már beolvasott szöveghez az 
          újat és növelve a feldolgozott szöveg méretét. A beolvasott számokat pedig a route tömbe rakjuk.
        </para>

    </section>
    <section>
        <title>SamuCam</title>
        <para>
         Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben:
https://github.com/nbatfai/SamuCam
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>

        </para>
    </section>
    <section>
        <title>BrainB</title>
        <para>
            Megoldás forrása:
        </para>
        <para>

        </para>
    </section>
</chapter>  