<chapter xmlns="http://docbook.org/ns/docbook" 
    xmlns:xlink="http://www.w3.org/1999/xlink" 
    xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
        Írjunk olyan OO, leforduló Java és C++ kódcsipetet, amely megsérti a Liskov elvet! Mutassunk rá a megoldásra: jobb OO tervezés. 
        </para>
        <para>https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (93-99 fólia) 
(számos példa szerepel az elv megsértésére az UDPROG repóban, lásd pl. source/binom/Batfai-Barki/madarak/) </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/Liskov/Liskov_sertes">https://github.com/p-adrian05/BHAX/tree/master/textbook_programs/Liskov/Liskov_sertes</link>
        </para>
        <para>
            A Liskov elv azt jelenti, hogy ha S egy olyan osztály, amely egy T osztály leszármazottja, akkor az S objektum behelyettesíthető minden olyan helyre, ahol T típust várunk, anélkül, hogy a programrész tulajdonságai megváltoznának.
            Tehát az alosztályoknak ugyanúgy kell viselkedniük mint a szülőosztály, viszont ha az altípus más kivételt vált ki, mint amit az alaptípust, akkor ez gondot okozhat olyan helyen ahol egy alaptípus viselkedésére van felkészülve a használó. 
            Általánosabban az altípusnak csak bővítenie szabad az alaptípus viselkedését, nem korlátozni.
        </para>
        <para>
            Az elvet sértő java kód esetében a négyzet osztály leszármazottja a téglalap osztálynak, azonban a téglalap (szülő) területének megfelelő értéke (50) helyett 
            25-öt kapunk, mivel a négyzet objektum másképp viselkedik mint a szülő típus.
        </para>
        <para>
             Ennek elkerülése érdekében alaposabban kell megtervezni az öröklődést. Gondolni kell a viselkedésre is nem csak a struktúrára.
        </para>

        <programlisting language="java">
            <![CDATA[ 

class Rectangle {
    private int height;
    private int width;

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public int getArea() {
        return this.height * this.width;
    }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width);
    }

    @Override
    public void setHeight(int height) {
        super.setHeight(height);
        super.setWidth(height);
    }
}

public class LSP {
    public static void main(String args[]) {
        Rectangle rec = new Square();
        rec.setWidth(10);
        rec.setHeight(5);
        System.out.println(rec.getArea());
    }
}


]]>
        </programlisting>
        <screen>
            <![CDATA[
...BHAX\textbook_programs\Liskov\Liskov_sertes>javac LSP.java
...BHAX\textbook_programs\Liskov\Liskov_sertes>java LSP
25


 ]]>
        </screen>
        <para>
        Ugyanez ez a példa C++-ban.
        </para>
        <programlisting language="c++">
            <![CDATA[ 

#include <iostream>
class Rectangle
{

public:
    int r_height;
    int r_width;

    int getHeight()
    {
        return r_height;
    }

    virtual void setHeight(int height)
    {
        r_height = height;
    }

    int getWidth()
    {
        return r_width;
    }

    virtual void setWidth(int width)
    {
        r_width = width;
    }

    int getArea()
    {
        return r_width * r_height;
    }
};

class Square : public Rectangle
{

public:
    void setWidth(int width)
    {
        r_height = width;
        r_width = width;
    }

    void setHeight(int height)
    {
        r_height = height;
        r_width = height;
    }
};

int main()
{
    Rectangle *r = new Square();
    r->setWidth(10);
    r->setHeight(5);
    std::cout << r->getArea();
}


]]>
        </programlisting>
        <screen>
            <![CDATA[
...\BHAX\textbook_programs\Liskov\Liskov_sertes>g++ LSP.cpp -o LSP
...\BHAX\textbook_programs\Liskov\Liskov_sertes>LSP
25


 ]]>
        </screen>
    </section>
    <section>
        <title>Szülő-gyerek</title>
        <para>
       Írjunk Szülő-gyerek Java és C++ osztálydefiníciót, amelyben demonstrálni tudjuk, hogy az ősön keresztül csak az ős üzenetei küldhetőek!  </para>
        <para>
          https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_1.pdf (98. fólia) </para>
        <para>
          Megoldás forrása:  
        </para>
        <para>
            A kiterjesztett osztályban definiált függvényeket az ősosztály nem éri el, ezért hiába hoztuk létre az ősosztály (Person) típusaként a Person2 objektumot. Ebben az esetben Person2 kasztolással érhető csak el 
            az alosztályban definiált függvény.
        </para>
        <programlisting language="java">
            <![CDATA[ 

class Person {
    protected int age;
    protected String name;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return this.age;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Person2 extends Person {
    private String email;

    public Person2(String name, int age, String email) {
        super(name, age);
        this.email = email;
    }

    public String getEmail() {
        return this.email;
    }

}

class szuloGyerek {

    public static void main(String args[]) {
        Person person = new Person2("Pisti", 37, "email@email.com");

        System.out.println(person.getEmail());
        // System.out.println(((Person2) person).getEmail());
    }
}


]]>
        </programlisting>
        <screen>
            <![CDATA[
...BHAX\textbook_programs\Liskov\SzuloGyerek>javac szulogyerek.java
szulogyerek.java:46: error: cannot find symbol
        System.out.println(person.getEmail());
                                 ^
  symbol:   method getEmail()
  location: variable person of type Person
1 error
 ]]>
        </screen>
        <para>
        Ugyanez ez a példa C++-ban.
        </para>
        <programlisting language="c++">
            <![CDATA[ 

#include <iostream>
#include <string>
class Person
{
protected:
    int ageP;
    std::string nameP;

public:
    Person(std::string name, int age)
    {
        nameP = name;
        ageP = age;
    }

    void setAge(int age)
    {
        ageP = age;
    }

    std::string getName()
    {
        return nameP;
    }
    int getAge()
    {
        return ageP;
    }

    void setName(std::string name)
    {
        nameP = name;
    }
};

class Person2 : public Person
{
private:
    std::string emailP;

public:
    Person2(std::string name, int age, std::string email) : Person(name, age)
    {
        emailP = email;
    }
    std::string getEmail()
    {
        return emailP;
    }
};

int main()
{
    Person *person = new Person2("Pisti", 37, "email");
    td::cout << person->getEmail();
}

]]>
        </programlisting>
        <screen>
            <![CDATA[
...\BHAX\textbook_programs\Liskov\SzuloGyerek>g++ szulogyerek.cpp -o a
szulogyerek.cpp: In function 'int main()':
szulogyerek.cpp:56:26: error: 'class Person' has no member named 'getEmail'
     std::cout << person->getEmail();
                          ^
 ]]>
        </screen>
    </section>

    <section>
        <title>Anti OO</title>
        <para>
   A BBP algoritmussal a Pi hexadecimális kifejtésének a 0. pozíciótól számított 106, 107, 108 darab jegyét határozzuk meg C, C++, Java és C# nyelveken és vessük össze a futási időket! 
https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apas03.html#id561066   </para>
        <para>
        Javaban:
        </para>
        <programlisting language="java">
            <![CDATA[ 


public class PiBBPBench {

    public static double d16Sj(int d, int j) {

        double d16Sj = 0.0d;

        for (int k = 0; k <= d; ++k)
            d16Sj += (double) n16modk(d - k, 8 * k + j) / (double) (8 * k + j);

        return d16Sj - Math.floor(d16Sj);
    }

    public static long n16modk(int n, int k) {

        int t = 1;
        while (t <= n)
            t *= 2;

        long r = 1;

        while (true) {

            if (n >= t) {
                r = (16 * r) % k;
                n = n - t;
            }

            t = t / 2;

            if (t < 1)
                break;

            r = (r * r) % k;

        }

        return r;
    }

    public static void main(String args[]) {

        double d16Pi = 0.0d;

        double d16S1t = 0.0d;
        double d16S4t = 0.0d;
        double d16S5t = 0.0d;
        double d16S6t = 0.0d;

        int jegy = 0;

        long delta = System.currentTimeMillis();

        for (int d = 1000000; d < 1000001; ++d) {

            d16Pi = 0.0d;

            d16S1t = d16Sj(d, 1);
            d16S4t = d16Sj(d, 4);
            d16S5t = d16Sj(d, 5);
            d16S6t = d16Sj(d, 6);

            d16Pi = 4.0d * d16S1t - 2.0d * d16S4t - d16S5t - d16S6t;

            d16Pi = d16Pi - Math.floor(d16Pi);

            jegy = (int) Math.floor(16.0d * d16Pi);

        }

        System.out.println(jegy);
        delta = System.currentTimeMillis() - delta;
        System.out.println(delta / 1000.0);
    }
}


]]>
        </programlisting>
        <screen>
            <![CDATA[
...\BHAX\textbook_programs\Liskov\Anti_OO>java PiBBPBench
6
1.639
...\BHAX\textbook_programs\Liskov\Anti_OO>java PiBBPBench
7
19.305
...\BHAX\textbook_programs\Liskov\Anti_OO>java PiBBPBench
12
225.121
                          
 ]]>
        </screen>
        <para>
        C#:
        </para>
        <programlisting language="c#">
            <![CDATA[ 
public class PiBBPBench {
  
    public static double d16Sj(int d, int j) {
        
        double d16Sj = 0.0d;
        
        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);
        
     
        
        return d16Sj - System.Math.Floor(d16Sj);
    }
  
    public static long n16modk(int n, int k) {
        
        int t = 1;
        while(t <= n)
            t *= 2;
        
        long r = 1;
        
        while(true) {
            
            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }
            
            t = t/2;
            
            if(t < 1)
                break;
            
            r = (r*r) % k;
            
        }
        
        return r;
    }
   
     public static void Main(System.String[]args) { 
        
        double d16Pi = 0.0d;
        
        double d16S1t = 0.0d;
        double d16S4t = 0.0d;
        double d16S5t = 0.0d;
        double d16S6t = 0.0d;
        
        int jegy = 0;
        
        System.DateTime kezd = System.DateTime.Now;
        
        for(int d=1000000; d<1000001; ++d) {
            
            d16Pi = 0.0d;
            
            d16S1t = d16Sj(d, 1);
            d16S4t = d16Sj(d, 4);
            d16S5t = d16Sj(d, 5);
            d16S6t = d16Sj(d, 6);
            
            d16Pi = 4.0d*d16S1t - 2.0d*d16S4t - d16S5t - d16S6t;
            
            d16Pi = d16Pi - System.Math.Floor(d16Pi);
            
            jegy = (int)System.Math.Floor(16.0d*d16Pi);
            
        }
        
        System.Console.WriteLine(jegy);
        System.TimeSpan delta = System.DateTime.Now.Subtract(kezd);
        System.Console.WriteLine(delta.TotalMilliseconds/1000.0);
    }
} 
          

]]>
        </programlisting>
        <screen>
            <![CDATA[
...\BHAX\textbook_programs\Liskov\Anti_OO>PiBBPBench.exe
6
1,6717391
...\BHAX\textbook_programs\Liskov\Anti_OO>PiBBPBench.exe
7
19,675768
...\BHAX\textbook_programs\Liskov\Anti_OO>PiBBPBench.exe
12
228,7670749
                          
 ]]>
        </screen>
        <para>
        gcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1) 
        C++:
        </para>
        <programlisting language="c++">
            <![CDATA[ 
#include <iostream>
#include <math.h>
#include <time.h>
long n16MODk(int n, int k)
{
    int t = 1;
    while (t <= n)
    {
        t = t * 2;
    }
    if (t > n)
        t = t / 2;
    long r = 1;
    while (true)
    {
        if (n >= t)
        {
            r = (16 * r) % k;
            n = n - t;
        }
        t = t / 2;
        if (t < 1)
            break;
        r = (r * r) % k;
    }
    return r;
}
double d16Sj(int d, int j)
{
    double d16Sj = 0.0d;
    for (int i = 0; i <= d; ++i)
    {
        d16Sj += (double)(n16MODk(d - i, 8 * i + j)) / (double)(8 * i + j);
    }
    for (int i = d + 1; i <= 2 * d; ++i)
    {
        d16Sj += pow(16.0d, d - i) / (double)(8 * i + j);
    }
    return d16Sj - floor(d16Sj);
}
int main()
{
    double d16Pi = 0.0;
    double d16S1t = 0.0;
    double d16S4t = 0.0;
    double d16S5t = 0.0;
    double d16S6t = 0.0;
    int jegy = 0;
    clock_t delta = clock();
    for (int d = 1000000; d < 1000001; ++d)
    {
        d16Pi = 0.0;
        d16S1t = d16Sj(d, 1);
        d16S4t = d16Sj(d, 4);
        d16S5t = d16Sj(d, 5);
        d16S6t = d16Sj(d, 6);
        d16Pi = 4.0 * d16S1t - 2.0 * d16S4t - d16S5t - d16S6t;
        d16Pi = d16Pi - floor(d16Pi);
        jegy = (int)floor(16.0 * d16Pi);
    }
    std::cout << jegy << std::endl;
    delta = clock() - delta;
    std::cout << static_cast<double>(delta) / CLOCKS_PER_SEC << std::endl;
}

]]>
        </programlisting>
        <screen>
            <![CDATA[
.../BHAX/textbook_programs/Liskov/Anti_OO$ ./a
6
2.11241


.../BHAX/textbook_programs/Liskov/Anti_OO$ ./a
7
24.5971

.../BHAX/textbook_programs/Liskov/Anti_OO$ ./a
12
283.916


                          
 ]]>
        </screen>
         <para>
        C:
        </para>
        <programlisting language="c">
            <![CDATA[ 
#include <stdio.h>
#include <math.h>
#include <time.h>

long
n16modk (int n, int k)
{
  long r = 1;

  int t = 1;
  while (t <= n)
    t *= 2;

  for (;;)
    {

      if (n >= t)
	{
	  r = (16 * r) % k;
	  n = n - t;
	}

      t = t / 2;

      if (t < 1)
	break;

      r = (r * r) % k;

    }

  return r;
}


double
d16Sj (int d, int j)
{

  double d16Sj = 0.0;
  int k;

  for (k = 0; k <= d; ++k)
    d16Sj += (double) n16modk (d - k, 8 * k + j) / (double) (8 * k + j);


  return d16Sj - floor (d16Sj);
}


main ()
{

  double d16Pi = 0.0;

  double d16S1t = 0.0;
  double d16S4t = 0.0;
  double d16S5t = 0.0;
  double d16S6t = 0.0;

  int jegy;
  int d;

  clock_t delta = clock ();

  for (d = 100000000; d < 100000001; ++d)
    {

      d16Pi = 0.0;

      d16S1t = d16Sj (d, 1);
      d16S4t = d16Sj (d, 4);
      d16S5t = d16Sj (d, 5);
      d16S6t = d16Sj (d, 6);

      d16Pi = 4.0 * d16S1t - 2.0 * d16S4t - d16S5t - d16S6t;

      d16Pi = d16Pi - floor (d16Pi);

      jegy = (int) floor (16.0 * d16Pi);

    }

  printf ("%d\n", jegy);
  delta = clock () - delta;
  printf ("%f\n", (double) delta / CLOCKS_PER_SEC);
} 
 

]]>
        </programlisting>
        <screen>
            <![CDATA[
.../BHAX/textbook_programs/Liskov/Anti_OO$ ./pi
6
1.890325

...BHAX/textbook_programs/Liskov/Anti_OO$ ./pi
7
22.686366


.../BHAX/textbook_programs/Liskov/Anti_OO$ ./pi
12
264.254057
                          
 ]]>
        </screen>


    </section>

    <section>
        <title>Hello, Android!</title>
        <para>
Élesszük fel az SMNIST for Humans projektet! 
https://gitlab.com/nbatfai/smnist/tree/master/forHumans/SMNISTforHumansExp3/app/src/main Apró módosításokat eszközölj benne, pl. színvilág. 
        </para>
        <para>
          Megoldás forrása:  
        </para>
        <para>

        </para>

    </section>

    <section>
        <title>Ciklomatikus komplexitás</title>
        <para>
        Számoljuk ki valamelyik programunk függvényeinek ciklomatikus komplexitását! Lásd a fogalom tekintetében a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_2.pdf (77-79 fóliát)! 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>

        </para>

    </section>

</chapter>                
